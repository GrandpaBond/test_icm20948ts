{"entries":[{"timestamp":1760529402458,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":104,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":204,"length1":64,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":231,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"main.py","value":"pins.i2c_read_number(0, NumberFormat.INT8_LE, False)\npins.i2c_write_number(0, 0, NumberFormat.INT8_LE, False)\n"},{"type":"added","filename":"pins_extra.ts","value":"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n    }\n\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n    }\n}\n"}]},{"timestamp":1760529536635,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":682,"diffs":[[1,"pins.i2cReadNumber(0, NumberFormat.Int8LE, false)\npins.i2cWriteNumber(0, 0, NumberFormat.Int8LE, false)\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":244,"length1":47,"diffs":[[1,"        \"pins_extra.ts\"\n"]]},{"start1":275,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"pyprj\"\n"]]}]},{"type":"edited","filename":"pins_extra.ts","patch":[{"start1":1,"length1":85,"diffs":[[1,"/**\n* Use this file to define custom functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n"]]},{"start1":123,"length1":269,"diffs":[[1,"enum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n"]]},{"start1":197,"length1":68,"diffs":[[1,"/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n    }\n"]]},{"start1":587,"length1":271,"diffs":[[1,"    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n    }\n}\n"]]}]},{"type":"added","filename":"icm20948.ts","value":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\nnamespace ICM {\n\n    const CHIP_ID = 0xEA;\n    const I2C_ADDR = 0x68;\n    const I2C_ADDR_ALT = 0x69;\n    const ICM20948_BANK_SEL = 0x7f;\n\n    const ICM20948_I2C_MST_ODR_CONFIG = 0x00;\n    const ICM20948_I2C_MST_CTRL = 0x01;\n    const ICM20948_I2C_MST_DELAY_CTRL = 0x02;\n    const ICM20948_I2C_SLV0_ADDR = 0x03;\n    const ICM20948_I2C_SLV0_REG = 0x04;\n    const ICM20948_I2C_SLV0_CTRL = 0x05;\n    const ICM20948_I2C_SLV0_DO = 0x06;\n    const ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\n    const ICM20948_GYRO_SMPLRT_DIV = 0x00;\n    const ICM20948_GYRO_CONFIG_1 = 0x01;\n    const ICM20948_GYRO_CONFIG_2 = 0x02;\n\n    // Bank 0\n    const ICM20948_WHO_AM_I = 0x00;\n    const ICM20948_USER_CTRL = 0x03;\n    const ICM20948_PWR_MGMT_1 = 0x06;\n    const ICM20948_PWR_MGMT_2 = 0x07;\n    const ICM20948_INT_PIN_CFG = 0x0F;\n\n    const ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\n    const ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\n    const ICM20948_ACCEL_INTEL_CTRL = 0x12;\n    const ICM20948_ACCEL_WOM_THR = 0x13;\n    const ICM20948_ACCEL_CONFIG = 0x14;\n    const ICM20948_ACCEL_XOUT_H = 0x2D;\n    const ICM20948_GRYO_XOUT_H = 0x33;\n\n    const ICM20948_TEMP_OUT_H = 0x39;\n    const ICM20948_TEMP_OUT_L = 0x3A;\n\n    // Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\n    const ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\n    const ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\n    const ICM20948_ROOM_TEMP_OFFSET = 21;\n\n    const AK09916_I2C_ADDR = 0x0c;\n    const AK09916_CHIP_ID = 0x09;\n    const AK09916_WIA = 0x01;\n    const AK09916_ST1 = 0x10;\n    const AK09916_ST1_DOR = 0b00000010   // Data overflow bit\n    const AK09916_ST1_DRDY = 0b00000001  // Data ready bit\n    const AK09916_HXL = 0x11;\n    const AK09916_ST2 = 0x18;\n    const AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\n    const AK09916_CNTL2 = 0x31;\n    const AK09916_CNTL2_MODE = 0b00001111;\n    const AK09916_CNTL2_MODE_OFF = 0;\n    const AK09916_CNTL2_MODE_SINGLE = 1;\n    const AK09916_CNTL2_MODE_CONT1 = 2;\n    const AK09916_CNTL2_MODE_CONT2 = 4;\n    const AK09916_CNTL2_MODE_CONT3 = 6;\n    const AK09916_CNTL2_MODE_CONT4 = 8;\n    const AK09916_CNTL2_MODE_TEST = 16;\n    const AK09916_CNTL3 = 0x32;\n\n    function write(self, reg, value) {\n        /* Write byte to the sensor. */\n        //_bus.write_byte_data(_addr, reg, value);\n        pins.i2cWriteNumber(addr,)\n        time.sleep(0.0001);\n    }\n    function read(self, reg) {\n        /* Read byte from the sensor. */\n        return _bus.read_byte_data(_addr, reg);\n    }\n    function trigger_mag_io(self) {\n        user = read(ICM20948_USER_CTRL);\n        write(ICM20948_USER_CTRL, user | 0x20);\n        time.sleep(0.005);\n        write(ICM20948_USER_CTRL, user);\n    }\n    function read_bytes(self, reg, length = 1) {\n        /* Read byte(s) from the sensor. */\n        return _bus.read_i2c_block_data(_addr, reg, length);\n    }\n    function bank(self, value) {\n        /* Switch register bank. */\n        if (!_bank == value) {\n            write(ICM20948_BANK_SEL, value << 4);\n            _bank = value;\n        }\n        function mag_write(self, reg, value) {\n            /* Write a byte to the slave magnetometer. */\n            bank(3);\n            write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n            write(ICM20948_I2C_SLV0_REG, reg);\n            write(ICM20948_I2C_SLV0_DO, value);\n            bank(0);\n            trigger_mag_io();\n        }\n        function mag_read(self, reg) {\n            /* Read a byte from the slave magnetometer. */\n            bank(3);\n            write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n            write(ICM20948_I2C_SLV0_REG, reg);\n            write(ICM20948_I2C_SLV0_DO, 0xff);\n            write(ICM20948_I2C_SLV0_CTRL, 0x80 | 1)  // Read 1 byte\n        }\n        bank(0);\n        trigger_mag_io();\n    }\n    return read(ICM20948_EXT_SLV_SENS_DATA_00);\n}\nfunction mag_read_bytes(self, reg, length = 1) {\n    /* Read up to 24 bytes from the slave magnetometer. */\n    bank(3);\n    write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n    write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n    write(ICM20948_I2C_SLV0_REG, reg);\n    write(ICM20948_I2C_SLV0_DO, 0xff);\n    bank(0);\n    trigger_mag_io();\n}\nreturn read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n\nfunction magnetometer_ready(self) {\n    /* Check the magnetometer status ready bit. */\n    return mag_read(AK09916_ST1) & 0x01 > 0;\n}\nfunction read_magnetometer_data(self, timeout = 1.0) {\n    mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n    t_start = time.time();\n    while (!magnetometer_ready()) {\n        if (time.time() - t_start > timeout) {\n            throw RuntimeError('Timeout waiting for Magnetometer Ready');\n            time.sleep(0.00001);\n        }\n        data = mag_read_bytes(AK09916_HXL, 6);\n    }\n    // Read ST2 to confirm read finished,\n    // needed for continuous modes\n    // mag_read(AK09916_ST2)\n}\nx, y, z = struct.unpack('<hhh', bytearray(data));\n\n// Scale for magnetic flux density \"uT\"\n// from section 3.3 of the datasheet\n// This value is constant\nx *= 0.15;\ny *= 0.15;\nz *= 0.15;\n\nreturn x, y, z;\n\nfunction read_accelerometer_gyro_data(self) {\n    bank(0);\n    data = read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n}\nax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n\nbank(2);\n\n// Read accelerometer full scale range and\n// use it to compensate the reading to gs\nscale = (read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n// scale ranges from section 3.2 of the datasheet\ngs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\nax /= gs;\nay /= gs;\naz /= gs;\n\n// Read back the degrees per second rate and\n// use it to compensate the reading to dps\nscale = (read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n// scale ranges from section 3.1 of the datasheet\ndps = [131, 65.5, 32.8, 16.4][scale];\n\ngx /= dps;\ngy /= dps;\ngz /= dps;\n\nreturn ax, ay, az, gx, gy, gz;\n\nfunction set_accelerometer_sample_rate(self, rate = 125) {\n    /* Set the accelerometer sample rate in Hz. */\n    bank(2);\n    // 125Hz - 1.125 kHz / (1 + rate)\n    rate = Number((1125.0 / rate) - 1);\n    // TODO maybe use struct to pack and then write_bytes\n    write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n    write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n}\nfunction set_accelerometer_full_scale(self, scale = 16) {\n    /* Set the accelerometer fulls cale range to +- the supplied value. */\n    bank(2);\n    value = read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n    value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n    write(ICM20948_ACCEL_CONFIG, value);\n}\nfunction set_accelerometer_low_pass(self, enabled = true, mode = 5) {\n    /* Configure the accelerometer low pass filter. */\n    bank(2);\n    value = read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n    if (enabled) {\n        value |= 0b1;\n        value |= (mode & 0x07) << 4;\n        write(ICM20948_ACCEL_CONFIG, value);\n    }\n    function set_gyro_sample_rate(self, rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        bank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = Number((1125.0 / rate) - 1);\n        write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n    function set_gyro_full_scale(self, scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        bank(2);\n        value = read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        write(ICM20948_GYRO_CONFIG_1, value);\n    }\n    function set_gyro_low_pass(self, enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        bank(2);\n        value = read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            write(ICM20948_GYRO_CONFIG_1, value);\n        }\n        function read_temperature(self) {\n            /* Property to read the current IMU temperature */\n            // PWR_MGMT_1 defaults to leave temperature enabled\n            bank(0);\n            temp_raw_bytes = read_bytes(ICM20948_TEMP_OUT_H, 2);\n            temp_raw = Stringuct.unpack('>h', bytearray(temp_raw_bytes))[0];\n            temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n            return temperature_deg_c;\n        }\n        function __init__(self, i2c_addr = I2C_ADDR, i2c_bus = null) {\n            _bank = -1;\n            _addr = i2c_addr;\n\n            if (i2c_bus === null) {\n                from smbus2 var SMBus = require('SMBus');\n                _bus = SMBus(1);\n            } else {\n                _bus = i2c_bus;\n            }\n            bank(0);\n            if (!read(ICM20948_WHO_AM_I) == CHIP_ID) {\n                throw RuntimeError('Unable to find ICM20948');\n            }\n            write(ICM20948_PWR_MGMT_1, 0x80);\n            time.sleep(0.01);\n            write(ICM20948_PWR_MGMT_1, 0x01);\n            write(ICM20948_PWR_MGMT_2, 0x00);\n\n            bank(2);\n\n            set_gyro_sample_rate(100);\n            set_gyro_low_pass(enabled = true, mode = 5);\n            set_gyro_full_scale(250);\n\n            set_accelerometer_sample_rate(125);\n            set_accelerometer_low_pass(enabled = true, mode = 5);\n            set_accelerometer_full_scale(16);\n\n            bank(0);\n            write(ICM20948_INT_PIN_CFG, 0x30);\n\n            bank(3);\n            write(ICM20948_I2C_MST_CTRL, 0x4D);\n            write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n            if (!mag_read(AK09916_WIA) == AK09916_CHIP_ID) {\n                throw RuntimeError('Unable to find AK09916');\n            }\n            // Reset the magnetometer\n            mag_write(AK09916_CNTL3, 0x01);\n            while (mag_read(AK09916_CNTL3) == 0x01) {\n                time.sleep(0.0001);\n            }\n        }\n\n        if (__name__ == '__main__') {\n            imu = ICM20948();\n        }\n        while (true) {\n            x, y, z = imu.read_magnetometer_data();\n            ax, ay, az, gx, gy, gz = imu.read_accelerometer_gyro_data();\n        }\n        Logger.log(x, y, z, ax, ay, az, gx, gy, gz)\n        /*\nAccel: {ax:05.2f} {ay:05.2f} {az:05.2f}\nGyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\nMag:   {x:05.2f} {y:05.2f} {z:05.2f} */\n\n        time.sleep(0.25)\n"}]},{"timestamp":1760538114015,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"icm20948.ts","patch":[{"start1":2567,"length1":50,"diffs":[[1,"        return _bus.read_byte_data(_addr, reg);\n"]]}]}]},{"timestamp":1760607348019,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"icm20948.ts","patch":[{"start1":5359,"length1":70,"diffs":[[1,"ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n"]]}]}]},{"timestamp":1760607472565,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":681,"length1":406,"diffs":[[1,"}"]]}]},{"type":"edited","filename":"icm20948.ts","patch":[{"start1":9955,"length1":5,"diffs":[[1,"\n        if (__name__ == '__main__') {\n            imu = ICM20948();\n        }\n        while (true) {\n            x, y, z = imu.read_magnetometer_data();\n            ax, ay, az, gx, gy, gz = imu.read_accelerometer_gyro_data();\n        }\n        Logger.log(x, y, z, ax, ay, az, gx, gy, gz)\n        /*\nAccel: {ax:05.2f} {ay:05.2f} {az:05.2f}\nGyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\nMag:   {x:05.2f} {y:05.2f} {z:05.2f} */\n\n        time.sleep(0.25)\n"]]}]}]},{"timestamp":1760607795484,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pins_extra.ts","patch":[{"start1":698,"length1":2,"diffs":[[1,"}"]]}]}]},{"timestamp":1760608453850,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pins_extra.ts","patch":[{"start1":700,"length1":1,"diffs":[[1,""]]}]}]},{"timestamp":1760608454531,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pins_extra.ts","patch":[{"start1":701,"length1":735,"diffs":[[1,""]]}]},{"type":"edited","filename":"icm20948.ts","patch":[{"start1":8631,"length1":60,"diffs":[[1,"                from smbus2 var SMBus = require('SMBus');\n"]]}]}]},{"timestamp":1760609050175,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":104,"diffs":[[1,"\nfunction fetch_byte_reg(byte_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, byte_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Ubyte(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int8LE, false))\n}\n\nfunction fetch_word_reg(word_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, word_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Uword(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int16BE, false))\n}\n\n//-----------------------------------------------\n\nimu = ICM20948(); \n\nwhile (true) {\n    x, y, z = imu.read_magnetometer_data();\n    ax, ay, az, gx, gy, gz = imu.read_accelerometer_gyro_data();\n\n    Logger.log(x, y, z, ax, ay, az, gx, gy, gz)\n    /*\n    Accel: {ax:05.2f} {ay:05.2f} {az:05.2f}\n    Gyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\n    Mag:   {x:05.2f} {y:05.2f} {z:05.2f} */\n\n    pause(1000)\n} \n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":269,"length1":22,"diffs":[[1,"        \"icm20948.ts\"\n"]]},{"start1":298,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"pins_extra.ts","patch":[{"start1":0,"length1":3,"diffs":[[1,"\n"]]},{"start1":358,"length1":3,"diffs":[[1,""]]},{"start1":359,"length1":3,"diffs":[[1,""]]},{"start1":700,"length1":6,"diffs":[[1,"\n\n"]]},{"start1":882,"length1":3,"diffs":[[1,""]]},{"start1":883,"length1":3,"diffs":[[1,""]]},{"start1":1065,"length1":3,"diffs":[[1,""]]},{"start1":1066,"length1":3,"diffs":[[1,""]]},{"start1":1252,"length1":3,"diffs":[[1,""]]},{"start1":1253,"length1":3,"diffs":[[1,""]]},{"start1":1435,"length1":4,"diffs":[[1,"}"]]}]},{"type":"removed","filename":"icm20948.ts","value":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\nnamespace ICM {\n\n    const CHIP_ID = 0xEA;\n    const I2C_ADDR = 0x68;\n    const I2C_ADDR_ALT = 0x69;\n    const ICM20948_BANK_SEL = 0x7f;\n\n    const ICM20948_I2C_MST_ODR_CONFIG = 0x00;\n    const ICM20948_I2C_MST_CTRL = 0x01;\n    const ICM20948_I2C_MST_DELAY_CTRL = 0x02;\n    const ICM20948_I2C_SLV0_ADDR = 0x03;\n    const ICM20948_I2C_SLV0_REG = 0x04;\n    const ICM20948_I2C_SLV0_CTRL = 0x05;\n    const ICM20948_I2C_SLV0_DO = 0x06;\n    const ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\n    const ICM20948_GYRO_SMPLRT_DIV = 0x00;\n    const ICM20948_GYRO_CONFIG_1 = 0x01;\n    const ICM20948_GYRO_CONFIG_2 = 0x02;\n\n    // Bank 0\n    const ICM20948_WHO_AM_I = 0x00;\n    const ICM20948_USER_CTRL = 0x03;\n    const ICM20948_PWR_MGMT_1 = 0x06;\n    const ICM20948_PWR_MGMT_2 = 0x07;\n    const ICM20948_INT_PIN_CFG = 0x0F;\n\n    const ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\n    const ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\n    const ICM20948_ACCEL_INTEL_CTRL = 0x12;\n    const ICM20948_ACCEL_WOM_THR = 0x13;\n    const ICM20948_ACCEL_CONFIG = 0x14;\n    const ICM20948_ACCEL_XOUT_H = 0x2D;\n    const ICM20948_GRYO_XOUT_H = 0x33;\n\n    const ICM20948_TEMP_OUT_H = 0x39;\n    const ICM20948_TEMP_OUT_L = 0x3A;\n\n    // Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\n    const ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\n    const ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\n    const ICM20948_ROOM_TEMP_OFFSET = 21;\n\n    const AK09916_I2C_ADDR = 0x0c;\n    const AK09916_CHIP_ID = 0x09;\n    const AK09916_WIA = 0x01;\n    const AK09916_ST1 = 0x10;\n    const AK09916_ST1_DOR = 0b00000010   // Data overflow bit\n    const AK09916_ST1_DRDY = 0b00000001  // Data ready bit\n    const AK09916_HXL = 0x11;\n    const AK09916_ST2 = 0x18;\n    const AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\n    const AK09916_CNTL2 = 0x31;\n    const AK09916_CNTL2_MODE = 0b00001111;\n    const AK09916_CNTL2_MODE_OFF = 0;\n    const AK09916_CNTL2_MODE_SINGLE = 1;\n    const AK09916_CNTL2_MODE_CONT1 = 2;\n    const AK09916_CNTL2_MODE_CONT2 = 4;\n    const AK09916_CNTL2_MODE_CONT3 = 6;\n    const AK09916_CNTL2_MODE_CONT4 = 8;\n    const AK09916_CNTL2_MODE_TEST = 16;\n    const AK09916_CNTL3 = 0x32;\n\n    function write(self, reg, value) {\n        /* Write byte to the sensor. */\n        //_bus.write_byte_data(_addr, reg, value);\n        pins.i2cWriteNumber(addr,)\n        time.sleep(0.0001);\n    }\n    function read(self, reg) {\n        /* Read byte from the sensor. */\n        //return _bus.read_byte_data(_addr, reg);\n    }\n    function trigger_mag_io(self) {\n        user = read(ICM20948_USER_CTRL);\n        write(ICM20948_USER_CTRL, user | 0x20);\n        time.sleep(0.005);\n        write(ICM20948_USER_CTRL, user);\n    }\n    function read_bytes(self, reg, length = 1) {\n        /* Read byte(s) from the sensor. */\n        return _bus.read_i2c_block_data(_addr, reg, length);\n    }\n    function bank(self, value) {\n        /* Switch register bank. */\n        if (!_bank == value) {\n            write(ICM20948_BANK_SEL, value << 4);\n            _bank = value;\n        }\n        function mag_write(self, reg, value) {\n            /* Write a byte to the slave magnetometer. */\n            bank(3);\n            write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n            write(ICM20948_I2C_SLV0_REG, reg);\n            write(ICM20948_I2C_SLV0_DO, value);\n            bank(0);\n            trigger_mag_io();\n        }\n        function mag_read(self, reg) {\n            /* Read a byte from the slave magnetometer. */\n            bank(3);\n            write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n            write(ICM20948_I2C_SLV0_REG, reg);\n            write(ICM20948_I2C_SLV0_DO, 0xff);\n            write(ICM20948_I2C_SLV0_CTRL, 0x80 | 1)  // Read 1 byte\n        }\n        bank(0);\n        trigger_mag_io();\n    }\n    return read(ICM20948_EXT_SLV_SENS_DATA_00);\n}\nfunction mag_read_bytes(self, reg, length = 1) {\n    /* Read up to 24 bytes from the slave magnetometer. */\n    bank(3);\n    write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n    write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n    write(ICM20948_I2C_SLV0_REG, reg);\n    write(ICM20948_I2C_SLV0_DO, 0xff);\n    bank(0);\n    trigger_mag_io();\n}\nreturn read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n\nfunction magnetometer_ready(self) {\n    /* Check the magnetometer status ready bit. */\n    return mag_read(AK09916_ST1) & 0x01 > 0;\n}\nfunction read_magnetometer_data(self, timeout = 1.0) {\n    mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n    t_start = time.time();\n    while (!magnetometer_ready()) {\n        if (time.time() - t_start > timeout) {\n            throw RuntimeError('Timeout waiting for Magnetometer Ready');\n            time.sleep(0.00001);\n        }\n        data = mag_read_bytes(AK09916_HXL, 6);\n    }\n    // Read ST2 to confirm read finished,\n    // needed for continuous modes\n    // mag_read(AK09916_ST2)\n}\nx, y, z = struct.unpack('<hhh', bytearray(data));\n\n// Scale for magnetic flux density \"uT\"\n// from section 3.3 of the datasheet\n// This value is constant\nx *= 0.15;\ny *= 0.15;\nz *= 0.15;\n\nreturn x, y, z;\n\nfunction read_accelerometer_gyro_data(self) {\n    bank(0);\n    data = read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n}\n//ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n\nbank(2);\n\n// Read accelerometer full scale range and\n// use it to compensate the reading to gs\nscale = (read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n// scale ranges from section 3.2 of the datasheet\ngs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\nax /= gs;\nay /= gs;\naz /= gs;\n\n// Read back the degrees per second rate and\n// use it to compensate the reading to dps\nscale = (read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n// scale ranges from section 3.1 of the datasheet\ndps = [131, 65.5, 32.8, 16.4][scale];\n\ngx /= dps;\ngy /= dps;\ngz /= dps;\n\nreturn ax, ay, az, gx, gy, gz;\n\nfunction set_accelerometer_sample_rate(self, rate = 125) {\n    /* Set the accelerometer sample rate in Hz. */\n    bank(2);\n    // 125Hz - 1.125 kHz / (1 + rate)\n    rate = Number((1125.0 / rate) - 1);\n    // TODO maybe use struct to pack and then write_bytes\n    write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n    write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n}\nfunction set_accelerometer_full_scale(self, scale = 16) {\n    /* Set the accelerometer fulls cale range to +- the supplied value. */\n    bank(2);\n    value = read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n    value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n    write(ICM20948_ACCEL_CONFIG, value);\n}\nfunction set_accelerometer_low_pass(self, enabled = true, mode = 5) {\n    /* Configure the accelerometer low pass filter. */\n    bank(2);\n    value = read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n    if (enabled) {\n        value |= 0b1;\n        value |= (mode & 0x07) << 4;\n        write(ICM20948_ACCEL_CONFIG, value);\n    }\n    function set_gyro_sample_rate(self, rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        bank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = Number((1125.0 / rate) - 1);\n        write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n    function set_gyro_full_scale(self, scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        bank(2);\n        value = read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        write(ICM20948_GYRO_CONFIG_1, value);\n    }\n    function set_gyro_low_pass(self, enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        bank(2);\n        value = read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            write(ICM20948_GYRO_CONFIG_1, value);\n        }\n        function read_temperature(self) {\n            /* Property to read the current IMU temperature */\n            // PWR_MGMT_1 defaults to leave temperature enabled\n            bank(0);\n            temp_raw_bytes = read_bytes(ICM20948_TEMP_OUT_H, 2);\n            temp_raw = Stringuct.unpack('>h', bytearray(temp_raw_bytes))[0];\n            temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n            return temperature_deg_c;\n        }\n        function __init__(self, i2c_addr = I2C_ADDR, i2c_bus = null) {\n            _bank = -1;\n            _addr = i2c_addr;\n\n            if (i2c_bus === null) {\n                //from smbus2 var SMBus = require('SMBus');\n                _bus = SMBus(1);\n            } else {\n                _bus = i2c_bus;\n            }\n            bank(0);\n            if (!read(ICM20948_WHO_AM_I) == CHIP_ID) {\n                throw RuntimeError('Unable to find ICM20948');\n            }\n            write(ICM20948_PWR_MGMT_1, 0x80);\n            time.sleep(0.01);\n            write(ICM20948_PWR_MGMT_1, 0x01);\n            write(ICM20948_PWR_MGMT_2, 0x00);\n\n            bank(2);\n\n            set_gyro_sample_rate(100);\n            set_gyro_low_pass(enabled = true, mode = 5);\n            set_gyro_full_scale(250);\n\n            set_accelerometer_sample_rate(125);\n            set_accelerometer_low_pass(enabled = true, mode = 5);\n            set_accelerometer_full_scale(16);\n\n            bank(0);\n            write(ICM20948_INT_PIN_CFG, 0x30);\n\n            bank(3);\n            write(ICM20948_I2C_MST_CTRL, 0x4D);\n            write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n            if (!mag_read(AK09916_WIA) == AK09916_CHIP_ID) {\n                throw RuntimeError('Unable to find AK09916');\n            }\n            // Reset the magnetometer\n            mag_write(AK09916_CNTL3, 0x01);\n            while (mag_read(AK09916_CNTL3) == 0x01) {\n                time.sleep(0.0001);\n            }\n        }\n    }"},{"type":"added","filename":"icm20948.py","value":"import struct\nimport time\n\n__version__ = '1.0.0'\n\nCHIP_ID = 0xEA\nI2C_ADDR = 0x68\nI2C_ADDR_ALT = 0x69\nICM20948_BANK_SEL = 0x7f\n\nICM20948_I2C_MST_ODR_CONFIG = 0x00\nICM20948_I2C_MST_CTRL = 0x01\nICM20948_I2C_MST_DELAY_CTRL = 0x02\nICM20948_I2C_SLV0_ADDR = 0x03\nICM20948_I2C_SLV0_REG = 0x04\nICM20948_I2C_SLV0_CTRL = 0x05\nICM20948_I2C_SLV0_DO = 0x06\nICM20948_EXT_SLV_SENS_DATA_00 = 0x3B\n\nICM20948_GYRO_SMPLRT_DIV = 0x00\nICM20948_GYRO_CONFIG_1 = 0x01\nICM20948_GYRO_CONFIG_2 = 0x02\n\n# Bank 0\nICM20948_WHO_AM_I = 0x00\nICM20948_USER_CTRL = 0x03\nICM20948_PWR_MGMT_1 = 0x06\nICM20948_PWR_MGMT_2 = 0x07\nICM20948_INT_PIN_CFG = 0x0F\n\nICM20948_ACCEL_SMPLRT_DIV_1 = 0x10\nICM20948_ACCEL_SMPLRT_DIV_2 = 0x11\nICM20948_ACCEL_INTEL_CTRL = 0x12\nICM20948_ACCEL_WOM_THR = 0x13\nICM20948_ACCEL_CONFIG = 0x14\nICM20948_ACCEL_XOUT_H = 0x2D\nICM20948_GRYO_XOUT_H = 0x33\n\nICM20948_TEMP_OUT_H = 0x39\nICM20948_TEMP_OUT_L = 0x3A\n\n# Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nICM20948_TEMPERATURE_DEGREES_OFFSET = 21\nICM20948_TEMPERATURE_SENSITIVITY = 333.87\nICM20948_ROOM_TEMP_OFFSET = 21\n\nAK09916_I2C_ADDR = 0x0c\nAK09916_CHIP_ID = 0x09\nAK09916_WIA = 0x01\nAK09916_ST1 = 0x10\nAK09916_ST1_DOR = 0b00000010   # Data overflow bit\nAK09916_ST1_DRDY = 0b00000001  # Data self.ready bit\nAK09916_HXL = 0x11\nAK09916_ST2 = 0x18\nAK09916_ST2_HOFL = 0b00001000  # Magnetic sensor overflow bit\nAK09916_CNTL2 = 0x31\nAK09916_CNTL2_MODE = 0b00001111\nAK09916_CNTL2_MODE_OFF = 0\nAK09916_CNTL2_MODE_SINGLE = 1\nAK09916_CNTL2_MODE_CONT1 = 2\nAK09916_CNTL2_MODE_CONT2 = 4\nAK09916_CNTL2_MODE_CONT3 = 6\nAK09916_CNTL2_MODE_CONT4 = 8\nAK09916_CNTL2_MODE_TEST = 16\nAK09916_CNTL3 = 0x32\n\n\nclass ICM20948:\n    def write(self, reg, value):\n        \"\"\"Write byte to the sensor.\"\"\"\n        self._bus.write_byte_data(self._addr, reg, value)\n        time.sleep(0.0001)\n\n    def read(self, reg):\n        \"\"\"Read byte from the sensor.\"\"\"\n        return self._bus.read_byte_data(self._addr, reg)\n\n    def trigger_mag_io(self):\n        user = self.read(ICM20948_USER_CTRL)\n        self.write(ICM20948_USER_CTRL, user | 0x20)\n        time.sleep(0.005)\n        self.write(ICM20948_USER_CTRL, user)\n\n    def read_bytes(self, reg, length=1):\n        \"\"\"Read byte(s) from the sensor.\"\"\"\n        return self._bus.read_i2c_block_data(self._addr, reg, length)\n\n    def bank(self, value):\n        \"\"\"Switch register self.bank.\"\"\"\n        if not self._bank == value:\n            self.write(ICM20948_BANK_SEL, value << 4)\n            self._bank = value\n\n    def mag_write(self, reg, value):\n        \"\"\"Write a byte to the slave magnetometer.\"\"\"\n        self.bank(3)\n        self.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  # Write one byte\n        self.write(ICM20948_I2C_SLV0_REG, reg)\n        self.write(ICM20948_I2C_SLV0_DO, value)\n        self.bank(0)\n        self.trigger_mag_io()\n\n    def mag_read(self, reg):\n        \"\"\"Read a byte from the slave magnetometer.\"\"\"\n        self.bank(3)\n        self.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80)\n        self.write(ICM20948_I2C_SLV0_REG, reg)\n        self.write(ICM20948_I2C_SLV0_DO, 0xff)\n        self.write(ICM20948_I2C_SLV0_CTRL, 0x80 | 1)  # Read 1 byte\n\n        self.bank(0)\n        self.trigger_mag_io()\n\n        return self.read(ICM20948_EXT_SLV_SENS_DATA_00)\n\n    def mag_read_bytes(self, reg, length=1):\n        \"\"\"Read up to 24 bytes from the slave magnetometer.\"\"\"\n        self.bank(3)\n        self.write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length)\n        self.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80)\n        self.write(ICM20948_I2C_SLV0_REG, reg)\n        self.write(ICM20948_I2C_SLV0_DO, 0xff)\n        self.bank(0)\n        self.trigger_mag_io()\n\n        return self.read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length)\n\n    def magnetometer_ready(self):\n        \"\"\"Check the magnetometer status self.ready bit.\"\"\"\n        return self.mag_read(AK09916_ST1) & 0x01 > 0\n\n    def read_magnetometer_data(self, timeout=1.0):\n        self.mag_write(AK09916_CNTL2, 0x01)  # Trigger single measurement\n        t_start = time.time()\n        while not self.magnetometer_ready():\n            if time.time() - t_start > timeout:\n                raise RuntimeError(\"Timeout waiting for Magnetometer Ready\")\n            time.sleep(0.00001)\n\n        data = self.mag_read_bytes(AK09916_HXL, 6)\n\n        # Read ST2 to confirm self.read finished,\n        # needed for continuous modes\n        # self.mag_read(AK09916_ST2)\n\n        x, y, z = struct.unpack(\"<hhh\", bytearray(data))\n\n        # Scale for magnetic flux density \"uT\"\n        # from section 3.3 of the datasheet\n        # This value is constant\n        x *= 0.15\n        y *= 0.15\n        z *= 0.15\n\n        return x, y, z\n\n    def read_accelerometer_gyro_data(self):\n        self.bank(0)\n        data = self.read_bytes(ICM20948_ACCEL_XOUT_H, 12)\n\n        ax, ay, az, gx, gy, gz = struct.unpack(\">hhhhhh\", bytearray(data))\n\n        self.bank(2)\n\n        # Read accelerometer full scale range and\n        # use it to compensate the self.reading to gs\n        scale = (self.read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1\n\n        # scale ranges from section 3.2 of the datasheet\n        gs = [16384.0, 8192.0, 4096.0, 2048.0][scale]\n\n        ax /= gs\n        ay /= gs\n        az /= gs\n\n        # Read back the degrees per second rate and\n        # use it to compensate the self.reading to dps\n        scale = (self.read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1\n\n        # scale ranges from section 3.1 of the datasheet\n        dps = [131, 65.5, 32.8, 16.4][scale]\n\n        gx /= dps\n        gy /= dps\n        gz /= dps\n\n        return ax, ay, az, gx, gy, gz\n\n    def set_accelerometer_sample_rate(self, rate=125):\n        \"\"\"Set the accelerometer sample rate in Hz.\"\"\"\n        self.bank(2)\n        # 125Hz - 1.125 kHz / (1 + rate)\n        rate = int((1125.0 / rate) - 1)\n        # TODO maybe use struct to pack and then write_bytes\n        self.write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff)\n        self.write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff)\n\n    def set_accelerometer_full_scale(self, scale=16):\n        \"\"\"Set the accelerometer fulls cale range to +- the supplied value.\"\"\"\n        self.bank(2)\n        value = self.read(ICM20948_ACCEL_CONFIG) & 0b11111001\n        value |= {2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11}[scale] << 1\n        self.write(ICM20948_ACCEL_CONFIG, value)\n\n    def set_accelerometer_low_pass(self, enabled=True, mode=5):\n        \"\"\"Configure the accelerometer low pass filter.\"\"\"\n        self.bank(2)\n        value = self.read(ICM20948_ACCEL_CONFIG) & 0b10001110\n        if enabled:\n            value |= 0b1\n        value |= (mode & 0x07) << 4\n        self.write(ICM20948_ACCEL_CONFIG, value)\n\n    def set_gyro_sample_rate(self, rate=125):\n        \"\"\"Set the gyro sample rate in Hz.\"\"\"\n        self.bank(2)\n        # 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = int((1125.0 / rate) - 1)\n        self.write(ICM20948_GYRO_SMPLRT_DIV, rate)\n\n    def set_gyro_full_scale(self, scale=250):\n        \"\"\"Set the gyro full scale range to +- supplied value.\"\"\"\n        self.bank(2)\n        value = self.read(ICM20948_GYRO_CONFIG_1) & 0b11111001\n        value |= {250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11}[scale] << 1\n        self.write(ICM20948_GYRO_CONFIG_1, value)\n\n    def set_gyro_low_pass(self, enabled=True, mode=5):\n        \"\"\"Configure the gyro low pass filter.\"\"\"\n        self.bank(2)\n        value = self.read(ICM20948_GYRO_CONFIG_1) & 0b10001110\n        if enabled:\n            value |= 0b1\n        value |= (mode & 0x07) << 4\n        self.write(ICM20948_GYRO_CONFIG_1, value)\n\n    def read_temperature(self):\n        \"\"\"Property to read the current IMU temperature\"\"\"\n        # PWR_MGMT_1 defaults to leave temperature enabled\n        self.bank(0)\n        temp_raw_bytes = self.read_bytes(ICM20948_TEMP_OUT_H, 2)\n        temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0]\n        temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET\n        return temperature_deg_c\n\n    def __init__(self, i2c_addr=I2C_ADDR, i2c_bus=None):\n        self._bank = -1\n        self._addr = i2c_addr\n\n        if i2c_bus is None:\n            from smbus2 import SMBus\n            self._bus = SMBus(1)\n        else:\n            self._bus = i2c_bus\n\n        self.bank(0)\n        if not self.read(ICM20948_WHO_AM_I) == CHIP_ID:\n            raise RuntimeError(\"Unable to find ICM20948\")\n\n        self.write(ICM20948_PWR_MGMT_1, 0x80)\n        time.sleep(0.01)\n        self.write(ICM20948_PWR_MGMT_1, 0x01)\n        self.write(ICM20948_PWR_MGMT_2, 0x00)\n\n        self.bank(2)\n\n        self.set_gyro_sample_rate(100)\n        self.set_gyro_low_pass(enabled=True, mode=5)\n        self.set_gyro_full_scale(250)\n\n        self.set_accelerometer_sample_rate(125)\n        self.set_accelerometer_low_pass(enabled=True, mode=5)\n        self.set_accelerometer_full_scale(16)\n\n        self.bank(0)\n        self.write(ICM20948_INT_PIN_CFG, 0x30)\n\n        self.bank(3)\n        self.write(ICM20948_I2C_MST_CTRL, 0x4D)\n        self.write(ICM20948_I2C_MST_DELAY_CTRL, 0x01)\n\n        if not self.mag_read(AK09916_WIA) == AK09916_CHIP_ID:\n            raise RuntimeError(\"Unable to find AK09916\")\n\n        # Reset the magnetometer\n        self.mag_write(AK09916_CNTL3, 0x01)\n        while self.mag_read(AK09916_CNTL3) == 0x01:\n            time.sleep(0.0001)\n\n\nif __name__ == \"__main__\":\n    imu = ICM20948()\n\n    while True:\n        x, y, z = imu.read_magnetometer_data()\n        ax, ay, az, gx, gy, gz = imu.read_accelerometer_gyro_data()\n\n        print(f\"\"\"\nAccel: {ax:05.2f} {ay:05.2f} {az:05.2f}\nGyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\nMag:   {x:05.2f} {y:05.2f} {z:05.2f}\"\"\")\n\n        time.sleep(0.25)"}]},{"timestamp":1760609578306,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1984,"diffs":[[1,"pins.i2cReadNumber(0, NumberFormat.Int8LE, false)\npins.i2cWriteNumber(0, 0, NumberFormat.Int8LE, false)\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":244,"length1":24,"diffs":[[1,"        \"pins_extra.ts\",\n        \"icm20948.py\"\n"]]},{"start1":298,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"pyprj\"\n"]]}]},{"type":"edited","filename":"main.py","patch":[{"start1":0,"length1":0,"diffs":[[1,"pins.i2c_read_number(0, NumberFormat.INT8_LE, False)\npins.i2c_write_number(0, 0, NumberFormat.INT8_LE, False)\n"]]}]},{"type":"removed","filename":"icm20948.py","value":"import struct\nimport time\n\n__version__ = '1.0.0'\n\nCHIP_ID = 0xEA\nI2C_ADDR = 0x68\nI2C_ADDR_ALT = 0x69\nICM20948_BANK_SEL = 0x7f\n\nICM20948_I2C_MST_ODR_CONFIG = 0x00\nICM20948_I2C_MST_CTRL = 0x01\nICM20948_I2C_MST_DELAY_CTRL = 0x02\nICM20948_I2C_SLV0_ADDR = 0x03\nICM20948_I2C_SLV0_REG = 0x04\nICM20948_I2C_SLV0_CTRL = 0x05\nICM20948_I2C_SLV0_DO = 0x06\nICM20948_EXT_SLV_SENS_DATA_00 = 0x3B\n\nICM20948_GYRO_SMPLRT_DIV = 0x00\nICM20948_GYRO_CONFIG_1 = 0x01\nICM20948_GYRO_CONFIG_2 = 0x02\n\n# Bank 0\nICM20948_WHO_AM_I = 0x00\nICM20948_USER_CTRL = 0x03\nICM20948_PWR_MGMT_1 = 0x06\nICM20948_PWR_MGMT_2 = 0x07\nICM20948_INT_PIN_CFG = 0x0F\n\nICM20948_ACCEL_SMPLRT_DIV_1 = 0x10\nICM20948_ACCEL_SMPLRT_DIV_2 = 0x11\nICM20948_ACCEL_INTEL_CTRL = 0x12\nICM20948_ACCEL_WOM_THR = 0x13\nICM20948_ACCEL_CONFIG = 0x14\nICM20948_ACCEL_XOUT_H = 0x2D\nICM20948_GRYO_XOUT_H = 0x33\n\nICM20948_TEMP_OUT_H = 0x39\nICM20948_TEMP_OUT_L = 0x3A\n\n# Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nICM20948_TEMPERATURE_DEGREES_OFFSET = 21\nICM20948_TEMPERATURE_SENSITIVITY = 333.87\nICM20948_ROOM_TEMP_OFFSET = 21\n\nAK09916_I2C_ADDR = 0x0c\nAK09916_CHIP_ID = 0x09\nAK09916_WIA = 0x01\nAK09916_ST1 = 0x10\nAK09916_ST1_DOR = 0b00000010   # Data overflow bit\nAK09916_ST1_DRDY = 0b00000001  # Data self.ready bit\nAK09916_HXL = 0x11\nAK09916_ST2 = 0x18\nAK09916_ST2_HOFL = 0b00001000  # Magnetic sensor overflow bit\nAK09916_CNTL2 = 0x31\nAK09916_CNTL2_MODE = 0b00001111\nAK09916_CNTL2_MODE_OFF = 0\nAK09916_CNTL2_MODE_SINGLE = 1\nAK09916_CNTL2_MODE_CONT1 = 2\nAK09916_CNTL2_MODE_CONT2 = 4\nAK09916_CNTL2_MODE_CONT3 = 6\nAK09916_CNTL2_MODE_CONT4 = 8\nAK09916_CNTL2_MODE_TEST = 16\nAK09916_CNTL3 = 0x32\n\n\nclass ICM20948:\n    def write(self, reg, value):\n        \"\"\"Write byte to the sensor.\"\"\"\n        self._bus.write_byte_data(self._addr, reg, value)\n        time.sleep(0.0001)\n\n    def read(self, reg):\n        \"\"\"Read byte from the sensor.\"\"\"\n        return self._bus.read_byte_data(self._addr, reg)\n\n    def trigger_mag_io(self):\n        user = self.read(ICM20948_USER_CTRL)\n        self.write(ICM20948_USER_CTRL, user | 0x20)\n        time.sleep(0.005)\n        self.write(ICM20948_USER_CTRL, user)\n\n    def read_bytes(self, reg, length=1):\n        \"\"\"Read byte(s) from the sensor.\"\"\"\n        return self._bus.read_i2c_block_data(self._addr, reg, length)\n\n    def bank(self, value):\n        \"\"\"Switch register self.bank.\"\"\"\n        if not self._bank == value:\n            self.write(ICM20948_BANK_SEL, value << 4)\n            self._bank = value\n\n    def mag_write(self, reg, value):\n        \"\"\"Write a byte to the slave magnetometer.\"\"\"\n        self.bank(3)\n        self.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  # Write one byte\n        self.write(ICM20948_I2C_SLV0_REG, reg)\n        self.write(ICM20948_I2C_SLV0_DO, value)\n        self.bank(0)\n        self.trigger_mag_io()\n\n    def mag_read(self, reg):\n        \"\"\"Read a byte from the slave magnetometer.\"\"\"\n        self.bank(3)\n        self.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80)\n        self.write(ICM20948_I2C_SLV0_REG, reg)\n        self.write(ICM20948_I2C_SLV0_DO, 0xff)\n        self.write(ICM20948_I2C_SLV0_CTRL, 0x80 | 1)  # Read 1 byte\n\n        self.bank(0)\n        self.trigger_mag_io()\n\n        return self.read(ICM20948_EXT_SLV_SENS_DATA_00)\n\n    def mag_read_bytes(self, reg, length=1):\n        \"\"\"Read up to 24 bytes from the slave magnetometer.\"\"\"\n        self.bank(3)\n        self.write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length)\n        self.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80)\n        self.write(ICM20948_I2C_SLV0_REG, reg)\n        self.write(ICM20948_I2C_SLV0_DO, 0xff)\n        self.bank(0)\n        self.trigger_mag_io()\n\n        return self.read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length)\n\n    def magnetometer_ready(self):\n        \"\"\"Check the magnetometer status self.ready bit.\"\"\"\n        return self.mag_read(AK09916_ST1) & 0x01 > 0\n\n    def read_magnetometer_data(self, timeout=1.0):\n        self.mag_write(AK09916_CNTL2, 0x01)  # Trigger single measurement\n        t_start = time.time()\n        while not self.magnetometer_ready():\n            if time.time() - t_start > timeout:\n                raise RuntimeError(\"Timeout waiting for Magnetometer Ready\")\n            time.sleep(0.00001)\n\n        data = self.mag_read_bytes(AK09916_HXL, 6)\n\n        # Read ST2 to confirm self.read finished,\n        # needed for continuous modes\n        # self.mag_read(AK09916_ST2)\n\n        x, y, z = struct.unpack(\"<hhh\", bytearray(data))\n\n        # Scale for magnetic flux density \"uT\"\n        # from section 3.3 of the datasheet\n        # This value is constant\n        x *= 0.15\n        y *= 0.15\n        z *= 0.15\n\n        return x, y, z\n\n    def read_accelerometer_gyro_data(self):\n        self.bank(0)\n        data = self.read_bytes(ICM20948_ACCEL_XOUT_H, 12)\n\n        ax, ay, az, gx, gy, gz = struct.unpack(\">hhhhhh\", bytearray(data))\n\n        self.bank(2)\n\n        # Read accelerometer full scale range and\n        # use it to compensate the self.reading to gs\n        scale = (self.read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1\n\n        # scale ranges from section 3.2 of the datasheet\n        gs = [16384.0, 8192.0, 4096.0, 2048.0][scale]\n\n        ax /= gs\n        ay /= gs\n        az /= gs\n\n        # Read back the degrees per second rate and\n        # use it to compensate the self.reading to dps\n        scale = (self.read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1\n\n        # scale ranges from section 3.1 of the datasheet\n        dps = [131, 65.5, 32.8, 16.4][scale]\n\n        gx /= dps\n        gy /= dps\n        gz /= dps\n\n        return ax, ay, az, gx, gy, gz\n\n    def set_accelerometer_sample_rate(self, rate=125):\n        \"\"\"Set the accelerometer sample rate in Hz.\"\"\"\n        self.bank(2)\n        # 125Hz - 1.125 kHz / (1 + rate)\n        rate = int((1125.0 / rate) - 1)\n        # TODO maybe use struct to pack and then write_bytes\n        self.write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff)\n        self.write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff)\n\n    def set_accelerometer_full_scale(self, scale=16):\n        \"\"\"Set the accelerometer fulls cale range to +- the supplied value.\"\"\"\n        self.bank(2)\n        value = self.read(ICM20948_ACCEL_CONFIG) & 0b11111001\n        value |= {2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11}[scale] << 1\n        self.write(ICM20948_ACCEL_CONFIG, value)\n\n    def set_accelerometer_low_pass(self, enabled=True, mode=5):\n        \"\"\"Configure the accelerometer low pass filter.\"\"\"\n        self.bank(2)\n        value = self.read(ICM20948_ACCEL_CONFIG) & 0b10001110\n        if enabled:\n            value |= 0b1\n        value |= (mode & 0x07) << 4\n        self.write(ICM20948_ACCEL_CONFIG, value)\n\n    def set_gyro_sample_rate(self, rate=125):\n        \"\"\"Set the gyro sample rate in Hz.\"\"\"\n        self.bank(2)\n        # 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = int((1125.0 / rate) - 1)\n        self.write(ICM20948_GYRO_SMPLRT_DIV, rate)\n\n    def set_gyro_full_scale(self, scale=250):\n        \"\"\"Set the gyro full scale range to +- supplied value.\"\"\"\n        self.bank(2)\n        value = self.read(ICM20948_GYRO_CONFIG_1) & 0b11111001\n        value |= {250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11}[scale] << 1\n        self.write(ICM20948_GYRO_CONFIG_1, value)\n\n    def set_gyro_low_pass(self, enabled=True, mode=5):\n        \"\"\"Configure the gyro low pass filter.\"\"\"\n        self.bank(2)\n        value = self.read(ICM20948_GYRO_CONFIG_1) & 0b10001110\n        if enabled:\n            value |= 0b1\n        value |= (mode & 0x07) << 4\n        self.write(ICM20948_GYRO_CONFIG_1, value)\n\n    def read_temperature(self):\n        \"\"\"Property to read the current IMU temperature\"\"\"\n        # PWR_MGMT_1 defaults to leave temperature enabled\n        self.bank(0)\n        temp_raw_bytes = self.read_bytes(ICM20948_TEMP_OUT_H, 2)\n        temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0]\n        temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET\n        return temperature_deg_c\n\n    def __init__(self, i2c_addr=I2C_ADDR, i2c_bus=None):\n        self._bank = -1\n        self._addr = i2c_addr\n\n        if i2c_bus is None:\n            from smbus2 import SMBus\n            self._bus = SMBus(1)\n        else:\n            self._bus = i2c_bus\n\n        self.bank(0)\n        if not self.read(ICM20948_WHO_AM_I) == CHIP_ID:\n            raise RuntimeError(\"Unable to find ICM20948\")\n\n        self.write(ICM20948_PWR_MGMT_1, 0x80)\n        time.sleep(0.01)\n        self.write(ICM20948_PWR_MGMT_1, 0x01)\n        self.write(ICM20948_PWR_MGMT_2, 0x00)\n\n        self.bank(2)\n\n        self.set_gyro_sample_rate(100)\n        self.set_gyro_low_pass(enabled=True, mode=5)\n        self.set_gyro_full_scale(250)\n\n        self.set_accelerometer_sample_rate(125)\n        self.set_accelerometer_low_pass(enabled=True, mode=5)\n        self.set_accelerometer_full_scale(16)\n\n        self.bank(0)\n        self.write(ICM20948_INT_PIN_CFG, 0x30)\n\n        self.bank(3)\n        self.write(ICM20948_I2C_MST_CTRL, 0x4D)\n        self.write(ICM20948_I2C_MST_DELAY_CTRL, 0x01)\n\n        if not self.mag_read(AK09916_WIA) == AK09916_CHIP_ID:\n            raise RuntimeError(\"Unable to find AK09916\")\n\n        # Reset the magnetometer\n        self.mag_write(AK09916_CNTL3, 0x01)\n        while self.mag_read(AK09916_CNTL3) == 0x01:\n            time.sleep(0.0001)\n\n\nif __name__ == \"__main__\":\n    imu = ICM20948()\n\n    while True:\n        x, y, z = imu.read_magnetometer_data()\n        ax, ay, az, gx, gy, gz = imu.read_accelerometer_gyro_data()\n\n        print(f\"\"\"\nAccel: {ax:05.2f} {ay:05.2f} {az:05.2f}\nGyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\nMag:   {x:05.2f} {y:05.2f} {z:05.2f}\"\"\")\n\n        time.sleep(0.25)"}]},{"timestamp":1760610170611,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1976,"length1":240,"diffs":[[1,"// try \n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":114,"length1":53,"diffs":[[1,"        \"microphone\": \"*\"\n"]]}]}]},{"timestamp":1760610768108,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2034,"length1":54,"diffs":[[1,"\n"]]}]}]},{"timestamp":1760610917654,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pins_extra.ts","patch":[{"start1":363,"length1":6,"diffs":[[1,"\n"]]}]}]},{"timestamp":1760611958930,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pins_extra.ts","patch":[{"start1":363,"length1":7,"diffs":[[1,"pause\n"]]}]}]},{"timestamp":1760611963534,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pins_extra.ts","patch":[{"start1":360,"length1":22,"diffs":[[1,""]]},{"start1":363,"length1":1,"diffs":[[1,"pauseu\n"]]}]}]},{"timestamp":1760612395458,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1975,"length1":0,"diffs":[[1,"\n"]]},{"start1":2269,"length1":43,"diffs":[[1,""]]}]}]},{"timestamp":1760612952867,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1974,"length1":81,"diffs":[[1,"\n"]]}]}]},{"timestamp":1760613837971,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":271,"length1":47,"diffs":[[1,"        \"pins_extra.ts\"\n"]]}]},{"type":"added","filename":"LCM20948.ts","value":""}]},{"timestamp":1760614089843,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":0,"length1":11075,"diffs":[[1,""]]}]}]},{"timestamp":1760614688376,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":2296,"length1":35,"diffs":[[1,""]]},{"start1":2297,"length1":1,"diffs":[[1,""]]},{"start1":2433,"length1":102,"diffs":[[1,"        let twoBytes: u[] = [I2C_ADDR, reg]\n"]]},{"start1":2592,"length1":32,"diffs":[[1,"    function read(reg) {\n"]]},{"start1":2854,"length1":50,"diffs":[[1,"    function read_bytes(reg, length = 1) {\n"]]},{"start1":3199,"length1":40,"diffs":[[1,"    function selectBank(value) {\n"]]},{"start1":3392,"length1":77,"diffs":[[1,"    function trigger_mag_io(self) {\n        user = read(ICM20948_USER_CTRL);\n"]]},{"start1":3620,"length1":51,"diffs":[[1,"    function mag_write(reg, value) {\n"]]},{"start1":3951,"length1":36,"diffs":[[1,"    function mag_read(reg) {\n"]]},{"start1":4318,"length1":54,"diffs":[[1,"    function mag_read_bytes(reg, length = 1) {\n"]]},{"start1":4872,"length1":51,"diffs":[[1,"        return mag_read(AK09916_ST1) & 0x01 > 0;\n"]]},{"start1":5050,"length1":35,"diffs":[[1,"        t_start = time.time();\n"]]},{"start1":5326,"length1":55,"diffs":[[1,"            data = mag_read_bytes(AK09916_HXL, 6);\n"]]},{"start1":5506,"length1":64,"diffs":[[1,"        x, y, z = struct.unpack('<hhh', bytearray(data));\n"]]},{"start1":5850,"length1":58,"diffs":[[1,"        data = read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n"]]},{"start1":6895,"length1":82,"diffs":[[1,"        rate = Number((1125.0 / rate) - 1);\n"]]},{"start1":7286,"length1":139,"diffs":[[1,"        value = read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n        value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n"]]},{"start1":7615,"length1":62,"diffs":[[1,"        value = read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n"]]},{"start1":7999,"length1":36,"diffs":[[1,"        rate = Number((1125.0 / rate) - 1);\n"]]},{"start1":8233,"length1":147,"diffs":[[1,"        value = read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n"]]},{"start1":8555,"length1":63,"diffs":[[1,"        value = read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n"]]},{"start1":8939,"length1":286,"diffs":[[1,"        temp_raw_bytes = read_bytes(ICM20948_TEMP_OUT_H, 2);\n        temp_raw = Stringuct.unpack('>h', bytearray(temp_raw_bytes))[0];\n        temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n"]]}]}]},{"timestamp":1760615286325,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":2311,"length1":55,"diffs":[[1,"    let _bank = -1 \n"]]},{"start1":3383,"length1":33,"diffs":[[1,"        if (!_bank == value) {\n"]]},{"start1":5195,"length1":39,"diffs":[[1,"        let t_start = time.time();\n"]]},{"start1":5270,"length1":139,"diffs":[[1,"            if (time.time() - t_start > timeout) {\n                throw RuntimeError('Timeout waiting for Magnetometer Ready');\n"]]},{"start1":5723,"length1":54,"diffs":[[1,""]]},{"start1":6076,"length1":78,"diffs":[[1,"        ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n"]]}]}]},{"timestamp":1760615625146,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":2311,"length1":65,"diffs":[[1,"    let _bank = -1 // currently-selected register-bank\n"]]},{"start1":3418,"length1":43,"diffs":[[1,"        if (!(_bank == value)) {\n"]]},{"start1":3501,"length1":37,"diffs":[[1,"            _bank = value;\n"]]},{"start1":9659,"length1":30,"diffs":[[1,"        _bank = -1;\n"]]}]}]},{"timestamp":1760629243909,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":2376,"length1":5,"diffs":[[1,""]]}]}]},{"timestamp":1760629248263,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":2311,"length1":75,"diffs":[[1,"    let imuRegisterBank = -1 // currently-selected register-bank\n    \n"]]},{"start1":3433,"length1":40,"diffs":[[1,"        if (!(imuRegisterBank == value)) {\n"]]},{"start1":3526,"length1":34,"diffs":[[1,"            imuRegisterBank = value;\n"]]},{"start1":6207,"length1":0,"diffs":[[1,"        \n"]]},{"start1":6294,"length1":77,"diffs":[[1,""]]},{"start1":6420,"length1":63,"diffs":[[1,"        scale = (read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n"]]},{"start1":9694,"length1":27,"diffs":[[1,"        imuRegisterBank = -1;\n"]]}]}]},{"timestamp":1760629839720,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":6324,"length1":254,"diffs":[[1,"        let ax = data[]\n        let \n"]]},{"start1":6609,"length1":59,"diffs":[[1,"        gs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n"]]}]}]},{"timestamp":1760629981989,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":7164,"length1":50,"diffs":[[1,"        dps = [131, 65.5, 32.8, 16.4][scale];\n"]]}]}]},{"timestamp":1760631447495,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":9663,"length1":76,"diffs":[[1,"        let temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0];\n"]]}]}]},{"timestamp":1760631471293,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":232,"length1":53,"diffs":[[1,""]]},{"start1":1625,"length1":51,"diffs":[[1,""]]},{"start1":2373,"length1":57,"diffs":[[1,"    let imu \n"]]},{"start1":9739,"length1":68,"diffs":[[1,""]]},{"start1":9927,"length1":49,"diffs":[[1,"    function initLcm20948(i2c_addr = I2C_ADDR, i2c_bus = null) {\n"]]},{"start1":10019,"length1":31,"diffs":[[1,"        _addr = i2c_addr;\n"]]},{"start1":10286,"length1":145,"diffs":[[1,"    if (!read(ICM20948_WHO_AM_I) == CHIP_ID) {\n        throw RuntimeError('Unable to find ICM20948');\n"]]},{"start1":10600,"length1":32,"diffs":[[1,"    set_gyro_low_pass(enabled = true, mode = 5);\n"]]},{"start1":10982,"length1":150,"diffs":[[1,"    if (!mag_read(AK09916_WIA) == AK09916_CHIP_ID) {\n        throw RuntimeError('Unable to find AK09916');\n"]]}]}]},{"timestamp":1760632032750,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1974,"length1":4,"diffs":[[1,""]]},{"start1":2055,"length1":1,"diffs":[[1,""]]},{"start1":2349,"length1":711,"diffs":[[1,"pins.i2cWriteBuffer(I2C_ADDR,buffer,false)"]]}]},{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":10951,"length1":41,"diffs":[[1,"    set_accelerometer_low_pass(enabled = true, mode = 5);\n"]]}]}]},{"timestamp":1760632543683,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2400,"length1":21,"diffs":[[1,"let imu = New (ICM20948())\n"]]},{"start1":2574,"length1":434,"diffs":[[1,"        datalogger.createCV(\"Mag_X\", [mag[0]),\n        datalogger.createCV(\"Mag_Y\", [mag[1]),\n        datalogger.createCV(\"Mag_Z\", [mag[0]),\n        datalogger.createCV(\"Gyro_X\", ax),\n        datalogger.createCV(\"Accel_X\", ax),\n        datalogger.createCV(\"Accel_X\", ax),\n        x,y,z,ax,ay,az,gx,gy,gz\n        )\n    \n"]]}]},{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":110,"length1":0,"diffs":[[1,"\n"]]},{"start1":11524,"length1":5,"diffs":[[1,""]]}]}]},{"timestamp":1760633078715,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":2399,"length1":21,"diffs":[[1,""]]},{"start1":2414,"length1":552,"diffs":[[1,"    let registerBank = -1 // currently-selected register-bank\n    let imuAddress = 0 // I2C master address of ICM20948\n"]]},{"start1":2534,"length1":23,"diffs":[[1,""]]},{"start1":2535,"length1":830,"diffs":[[1,"    function write(reg:uint8, value:uint8) {\n"]]},{"start1":2888,"length1":28,"diffs":[[1,"    function read(reg: uint8) {\n"]]},{"start1":3157,"length1":41,"diffs":[[1,"    function read_bytes(reg: uint8, length = 1) {\n"]]},{"start1":3509,"length1":31,"diffs":[[1,"    function selectBank(value: uint8) {\n"]]},{"start1":3725,"length1":23,"diffs":[[1,"    function trigger_mag_io() {\n"]]},{"start1":3953,"length1":42,"diffs":[[1,"    function mag_write(reg: uint8, value: uint8) {\n"]]},{"start1":4298,"length1":32,"diffs":[[1,"    function mag_read(reg: uint8) {\n"]]},{"start1":4672,"length1":50,"diffs":[[1,"    function mag_read_bytes(reg: uint8, length = 1) {\n"]]},{"start1":5142,"length1":32,"diffs":[[1,"    function magnetometer_ready() {\n"]]},{"start1":5290,"length1":49,"diffs":[[1,"    function read_magnetometer_data(timeout = 1.0) {\n"]]},{"start1":6225,"length1":37,"diffs":[[1,"\n    function read_accelerometer_gyro_data() {\n"]]},{"start1":7466,"length1":48,"diffs":[[1,"    function set_accelerometer_sample_rate(rate = 125) {\n"]]},{"start1":7914,"length1":52,"diffs":[[1,"    function set_accelerometer_full_scale(scale = 16) {\n"]]},{"start1":8262,"length1":64,"diffs":[[1,"    function set_accelerometer_low_pass(enabled = true, mode = 5) {\n"]]},{"start1":8629,"length1":44,"diffs":[[1,"    function set_gyro_sample_rate(rate = 125) {\n"]]},{"start1":8889,"length1":44,"diffs":[[1,"    function set_gyro_full_scale(scale = 250) {\n"]]},{"start1":9225,"length1":55,"diffs":[[1,"    function set_gyro_low_pass(enabled = true, mode = 5) {\n"]]},{"start1":9569,"length1":25,"diffs":[[1,"    function read_temperature() {\n"]]},{"start1":10141,"length1":0,"diffs":[[1,"\n    function initLcm20948(i2c_addr = I2C_ADDR) {\n        registerBank = -1;\n        imuAddress = i2c_addr;\n        /*\n            if (i2c_bus === null) {\n                from smbus2 var SMBus = require('SMBus');\n                _bus = SMBus(1);\n            } else {\n                _bus = i2c_bus;\n            }\n        */\n"]]},{"start1":10471,"length1":1,"diffs":[[1,"    selectBank(0);\n    if (read(ICM20948_WHO_AM_I) != CHIP_ID) {\n        //throw RuntimeError('Unable to find ICM20948');\n        control.panic(ICM20948_NOT_FOUND)\n    }\n    write(ICM20948_PWR_MGMT_1, 0x80);\n    basic.pause(10) //time.sleep(0.01);\n    write(ICM20948_PWR_MGMT_1, 0x01);\n    write(ICM20948_PWR_MGMT_2, 0x00);\n\n    selectBank(2);\n\n    set_gyro_sample_rate(100);\n    set_gyro_low_pass(true, 5);\n    set_gyro_full_scale(250);\n\n    set_accelerometer_sample_rate(125);\n    set_accelerometer_low_pass(true, 5);\n    set_accelerometer_full_scale(16);\n\n    selectBank(0);\n    write(ICM20948_INT_PIN_CFG, 0x30);\n\n    selectBank(3);\n    write(ICM20948_I2C_MST_CTRL, 0x4D);\n    write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n    if (mag_read(AK09916_WIA) != AK09916_CHIP_ID) {\n        // throw RuntimeError('Unable to find AK09916');\n        control.panic(AK09916_NOT_FOUND)\n    }\n    // Reset the magnetometer\n    mag_write(AK09916_CNTL3, 0x01);\n    while (mag_read(AK09916_CNTL3) == 0x01) {\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n    \n\n}\n    /*\n    if (__name__ == '__main__') {\n        imu = ICM20948();\n    }\n        while (true) {\n            x, y, z = imu.read_magnetometer_data();\n            ax, ay, az, gx, gy, gz = imu.read_accelerometer_gyro_data();\n        }\n            Logger.log(x,y,z,ax,ay,az,gx,gy,gz)\n            /*\n    //Accel: {ax:05.2f} {ay:05.2f} {az:05.2f}\n    //Gyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\n    //Mag:   {x:05.2f} {y:05.2f} {z:05.2f} \n\n    basic.pause(250) //time.sleep(0.25)\n        */\n"]]}]}]},{"timestamp":1760633667101,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":2398,"length1":15,"diffs":[[1,""]]},{"start1":2420,"length1":56,"diffs":[[1,"    // GLOBALS\n    registerBank: number // currently-selected register-bank\n    imuAddress: number // I2C master address of ICM20948\n    \n    constructor() {\n        imuAddress = 0\n        registerBank = -1\n        selectBank(0);\n        if (read(ICM20948_WHO_AM_I) != CHIP_ID) {\n            //throw RuntimeError('Unable to find ICM20948');\n            control.panic(ICM20948_NOT_FOUND)\n        }\n        write(ICM20948_PWR_MGMT_1, 0x80);\n        basic.pause(10) //time.sleep(0.01);\n        write(ICM20948_PWR_MGMT_1, 0x01);\n        write(ICM20948_PWR_MGMT_2, 0x00);\n"]]},{"start1":2988,"length1":187,"diffs":[[1,"        selectBank(2);\n"]]},{"start1":3012,"length1":436,"diffs":[[1,"        set_gyro_sample_rate(100);\n        set_gyro_low_pass(true, 5);\n        set_gyro_full_scale(250);\n"]]},{"start1":3118,"length1":32,"diffs":[[1,"        set_accelerometer_sample_rate(125);\n        set_accelerometer_low_pass(true, 5);\n        set_accelerometer_full_scale(16);\n"]]},{"start1":3250,"length1":132,"diffs":[[1,"        selectBank(0);\n        write(ICM20948_INT_PIN_CFG, 0x30);\n"]]},{"start1":3317,"length1":158,"diffs":[[1,"        selectBank(3);\n        write(ICM20948_I2C_MST_CTRL, 0x4D);\n        write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n"]]},{"start1":3435,"length1":665,"diffs":[[1,"        if (mag_read(AK09916_WIA) != AK09916_CHIP_ID) {\n            // throw RuntimeError('Unable to find AK09916');\n            control.panic(AK09916_NOT_FOUND)\n"]]},{"start1":3607,"length1":0,"diffs":[[1,"        // Reset the magnetometer\n        mag_write(AK09916_CNTL3, 0x01);\n        while (mag_read(AK09916_CNTL3) == 0x01) {\n            control.waitMicros(100) //time.sleep(0.0001);\n        }\n    }\n"]]},{"start1":3806,"length1":42,"diffs":[[1,"    write(reg:uint8, value:uint8) {\n"]]},{"start1":3882,"length1":56,"diffs":[[1,"        //_bus.write_byte_data(_addr, reg, value);\n"]]},{"start1":4150,"length1":1,"diffs":[[1,"    \n"]]},{"start1":4825,"length1":144,"diffs":[[1,"        if (!(registerBank == value)) {\n            write(ICM20948_BANK_SEL, value << 4);\n            registerBank = value;\n"]]},{"start1":4988,"length1":103,"diffs":[[1,"        let user = read(ICM20948_USER_CTRL);\n        write(ICM20948_USER_CTRL, user | 0x20);\n"]]},{"start1":5135,"length1":46,"diffs":[[1,"        write(ICM20948_USER_CTRL, user);\n"]]},{"start1":5184,"length1":47,"diffs":[[1,"    mag_write(reg: uint8, value: uint8) {\n"]]},{"start1":5303,"length1":177,"diffs":[[1,"        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, value);\n"]]},{"start1":5520,"length1":1,"diffs":[[1,"    \n"]]},{"start1":5630,"length1":165,"diffs":[[1,"        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, 0xff);\n"]]},{"start1":5890,"length1":1,"diffs":[[1,"    \n"]]},{"start1":5940,"length1":63,"diffs":[[1,"    /* Read up to 24 bytes from the slave magnetometer. */\n"]]},{"start1":6022,"length1":231,"diffs":[[1,"        write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, 0xff);\n"]]},{"start1":6356,"length1":1,"diffs":[[1,"    \n"]]},{"start1":6500,"length1":1,"diffs":[[1,"    \n"]]},{"start1":6549,"length1":75,"diffs":[[1,"        mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n"]]},{"start1":7491,"length1":63,"diffs":[[1,"        let data = read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n"]]},{"start1":8912,"length1":198,"diffs":[[1,"        // TODO maybe use struct to pack and then write_bytes\n        write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n        write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n"]]},{"start1":9101,"length1":1,"diffs":[[1,"    \n"]]},{"start1":9255,"length1":67,"diffs":[[1,"        let value = read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n"]]},{"start1":9394,"length1":50,"diffs":[[1,"        write(ICM20948_ACCEL_CONFIG, value);\n"]]},{"start1":9445,"length1":1,"diffs":[[1,"    \n"]]},{"start1":9591,"length1":67,"diffs":[[1,"        let value = read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n"]]},{"start1":9743,"length1":54,"diffs":[[1,"            write(ICM20948_ACCEL_CONFIG, value);\n"]]},{"start1":9808,"length1":1,"diffs":[[1,"    \n"]]},{"start1":10011,"length1":52,"diffs":[[1,"        write(ICM20948_GYRO_SMPLRT_DIV, rate);\n"]]},{"start1":10064,"length1":1,"diffs":[[1,"    \n"]]},{"start1":10197,"length1":68,"diffs":[[1,"        let value = read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n"]]},{"start1":10344,"length1":51,"diffs":[[1,"        write(ICM20948_GYRO_CONFIG_1, value);\n"]]},{"start1":10396,"length1":1,"diffs":[[1,"    \n"]]},{"start1":10524,"length1":68,"diffs":[[1,"        let value = read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n"]]},{"start1":10683,"length1":51,"diffs":[[1,"        write(ICM20948_GYRO_CONFIG_1, value);\n"]]},{"start1":10903,"length1":70,"diffs":[[1,"        let temp_raw_bytes = read_bytes(ICM20948_TEMP_OUT_H, 2);\n"]]},{"start1":11299,"length1":2,"diffs":[[1,"    }\n"]]}]}]},{"timestamp":1760634266125,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":5538,"length1":47,"diffs":[[1,"    mag_this.write(reg: uint8, value: uint8) {\n"]]}]}]},{"timestamp":1760687542148,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":5538,"length1":42,"diffs":[[1,"    this.mag_write(reg: uint8, value: uint8) {\n"]]}]}]},{"timestamp":1760687576593,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":47,"length1":3,"diffs":[[1,""]]},{"start1":1975,"length1":1,"diffs":[[1,"/*\n"]]},{"start1":2400,"length1":33,"diffs":[[1,"let imu = new(ICM())\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":24,"diffs":[[1,"    \"name\": \"test_i2c\",\n"]]}]},{"type":"edited","filename":"LCM20948.ts","patch":[{"start1":2492,"length1":41,"diffs":[[1,"        constructor(myAddress:number) {\n"]]},{"start1":2900,"length1":51,"diffs":[[1,"            this.this.write(ICM20948_PWR_MGMT_1, 0x80);\n"]]},{"start1":3004,"length1":102,"diffs":[[1,"            this.this.write(ICM20948_PWR_MGMT_1, 0x01);\n            this.this.write(ICM20948_PWR_MGMT_2, 0x00);\n"]]},{"start1":3474,"length1":52,"diffs":[[1,"            this.this.write(ICM20948_INT_PIN_CFG, 0x30);\n"]]},{"start1":3564,"length1":112,"diffs":[[1,"            this.this.write(ICM20948_I2C_MST_CTRL, 0x4D);\n            this.this.write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n"]]},{"start1":3918,"length1":49,"diffs":[[1,"            this.mag_this.write(AK09916_CNTL3, 0x01);\n"]]},{"start1":4160,"length1":104,"diffs":[[1,"        /* Write byte to the sensor. */\n        //_bus.this.write_byte_data(_addr, reg, value);\n"]]},{"start1":4257,"length1":240,"diffs":[[1,"        let twoBytes = pins.createBuffer(2)\n        twoBytes[0] = I2C_ADDR\n        twoBytes[1] = reg\n        pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n"]]},{"start1":5189,"length1":55,"diffs":[[1,"            this.this.write(ICM20948_BANK_SEL, value << 4);\n"]]},{"start1":5634,"length1":28,"diffs":[[1,"        selectBank(3);\n"]]},{"start1":5834,"length1":59,"diffs":[[1,"        selectBank(0);\n        trigger_mag_io();\n"]]},{"start1":5972,"length1":28,"diffs":[[1,"        selectBank(3);\n"]]},{"start1":6161,"length1":59,"diffs":[[1,"        selectBank(0);\n        trigger_mag_io();\n"]]},{"start1":6211,"length1":57,"diffs":[[1,"        return read(ICM20948_EXT_SLV_SENS_DATA_00);\n"]]},{"start1":6379,"length1":28,"diffs":[[1,"        selectBank(3);\n"]]},{"start1":6633,"length1":59,"diffs":[[1,"        selectBank(0);\n        trigger_mag_io();\n"]]},{"start1":6683,"length1":71,"diffs":[[1,"        return read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n"]]},{"start1":6839,"length1":56,"diffs":[[1,"        return (mag_read(AK09916_ST1) & 0x01) > 0;\n"]]},{"start1":6941,"length1":75,"diffs":[[1,"        mag_this.write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n"]]},{"start1":7055,"length1":45,"diffs":[[1,"        while (!magnetometer_ready()) {\n"]]},{"start1":7310,"length1":60,"diffs":[[1,"            let data = mag_read_bytes(AK09916_HXL, 6);\n"]]},{"start1":7460,"length1":38,"diffs":[[1,"        // mag_read(AK09916_ST2)\n"]]},{"start1":7865,"length1":28,"diffs":[[1,"        selectBank(0);\n"]]},{"start1":8324,"length1":28,"diffs":[[1,"        selectBank(2);\n"]]},{"start1":8449,"length1":68,"diffs":[[1,"        let scale = (read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n"]]},{"start1":8790,"length1":65,"diffs":[[1,"        scale = (read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n"]]},{"start1":9167,"length1":28,"diffs":[[1,"        selectBank(2);\n"]]},{"start1":9645,"length1":28,"diffs":[[1,"        selectBank(2);\n"]]},{"start1":9987,"length1":28,"diffs":[[1,"        selectBank(2);\n"]]},{"start1":10323,"length1":28,"diffs":[[1,"        selectBank(2);\n"]]},{"start1":10600,"length1":28,"diffs":[[1,"        selectBank(2);\n"]]},{"start1":10933,"length1":28,"diffs":[[1,"        selectBank(2);\n"]]},{"start1":11322,"length1":28,"diffs":[[1,"        selectBank(0);\n"]]}]}]},{"timestamp":1760688164203,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2,"length1":0,"diffs":[[1,"const CHIP_ID = 0xEA;\n"]]},{"start1":47,"length1":27,"diffs":[[1,""]]},{"start1":2435,"length1":46,"diffs":[[1,"let mag = []\nlet gyro = []\n"]]},{"start1":2565,"length1":20,"diffs":[[1,"    Logger.log(\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":296,"length1":22,"diffs":[[1,"        \"LCM20948.ts\"\n"]]}]},{"type":"removed","filename":"LCM20948.ts","value":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\nnamespace ICM {\n    const CHIP_ID = 0xEA;\n    const I2C_ADDR = 0x68;\n    const I2C_ADDR_ALT = 0x69;\n    const ICM20948_BANK_SEL = 0x7f;\n\n    const ICM20948_NOT_FOUND = 222; // Panic code!\n\n\n    const ICM20948_I2C_MST_ODR_CONFIG = 0x00;\n    const ICM20948_I2C_MST_CTRL = 0x01;\n    const ICM20948_I2C_MST_DELAY_CTRL = 0x02;\n    const ICM20948_I2C_SLV0_ADDR = 0x03;\n    const ICM20948_I2C_SLV0_REG = 0x04;\n    const ICM20948_I2C_SLV0_CTRL = 0x05;\n    const ICM20948_I2C_SLV0_DO = 0x06;\n    const ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\n    const ICM20948_GYRO_SMPLRT_DIV = 0x00;\n    const ICM20948_GYRO_CONFIG_1 = 0x01;\n    const ICM20948_GYRO_CONFIG_2 = 0x02;\n\n    // Bank 0\n    const ICM20948_WHO_AM_I = 0x00;\n    const ICM20948_USER_CTRL = 0x03;\n    const ICM20948_PWR_MGMT_1 = 0x06;\n    const ICM20948_PWR_MGMT_2 = 0x07;\n    const ICM20948_INT_PIN_CFG = 0x0F;\n\n    const ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\n    const ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\n    const ICM20948_ACCEL_INTEL_CTRL = 0x12;\n    const ICM20948_ACCEL_WOM_THR = 0x13;\n    const ICM20948_ACCEL_CONFIG = 0x14;\n    const ICM20948_ACCEL_XOUT_H = 0x2D;\n    const ICM20948_GRYO_XOUT_H = 0x33;\n\n    const ICM20948_TEMP_OUT_H = 0x39;\n    const ICM20948_TEMP_OUT_L = 0x3A;\n\n    // Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\n    const ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\n    const ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\n    const ICM20948_ROOM_TEMP_OFFSET = 21;\n\n    const AK09916_I2C_ADDR = 0x0c;\n    const AK09916_CHIP_ID = 0x09;\n    const AK09916_WIA = 0x01;\n    const AK09916_NOT_FOUND = 222; // Panic code!\n\n    const AK09916_ST1 = 0x10;\n    const AK09916_ST1_DOR = 0b00000010   // Data overflow bit\n    const AK09916_ST1_DRDY = 0b00000001  // Data ready bit\n    const AK09916_HXL = 0x11;\n    const AK09916_ST2 = 0x18;\n    const AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\n    const AK09916_CNTL2 = 0x31;\n    const AK09916_CNTL2_MODE = 0b00001111;\n    const AK09916_CNTL2_MODE_OFF = 0;\n    const AK09916_CNTL2_MODE_SINGLE = 1;\n    const AK09916_CNTL2_MODE_CONT1 = 2;\n    const AK09916_CNTL2_MODE_CONT2 = 4;\n    const AK09916_CNTL2_MODE_CONT3 = 6;\n    const AK09916_CNTL2_MODE_CONT4 = 8;\n    const AK09916_CNTL2_MODE_TEST = 16;\n    const AK09916_CNTL3 = 0x32;\n    // GLOBALS\n\n    class ICM20948 {\n        registerBank: number\n        imuAddress: number\n\n        constructor(myAddress: number) {\n            this.registerBank = -1; // currently-selected register-bank\n            this.imuAddress = myAddress; // I2C master address of ICM20948\n\n            this.selectBank(0);\n            if (this.read(ICM20948_WHO_AM_I) != CHIP_ID) {\n                //throw RuntimeError('Unable to find ICM20948');\n                control.panic(ICM20948_NOT_FOUND)\n            }\n            this.write(ICM20948_PWR_MGMT_1, 0x80);\n            basic.pause(10) //time.sleep(0.01);\n            this.write(ICM20948_PWR_MGMT_1, 0x01);\n            this.write(ICM20948_PWR_MGMT_2, 0x00);\n\n            this.selectBank(2);\n\n            this.set_gyro_sample_rate(100);\n            this.set_gyro_low_pass(true, 5);\n            this.set_gyro_full_scale(250);\n\n            this.set_accelerometer_sample_rate(125);\n            this.set_accelerometer_low_pass(true, 5);\n            this.set_accelerometer_full_scale(16);\n\n            this.selectBank(0);\n            this.write(ICM20948_INT_PIN_CFG, 0x30);\n\n            this.selectBank(3);\n            this.write(ICM20948_I2C_MST_CTRL, 0x4D);\n            this.write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n            if (this.mag_read(AK09916_WIA) != AK09916_CHIP_ID) {\n                // throw RuntimeError('Unable to find AK09916');\n                control.panic(AK09916_NOT_FOUND)\n            }\n            // Reset the magnetometer\n            this.mag_write(AK09916_CNTL3, 0x01);\n            while (this.mag_read(AK09916_CNTL3) == 0x01) {\n                control.waitMicros(100) //time.sleep(0.0001);\n            }\n        }\n\n        write(reg: uint8, value: uint8) {\n            /* Write byte to the sensor. */\n            //_bus.this.write_byte_data(_addr, reg, value);\n\n            let twoBytes = pins.createBuffer(2)\n            twoBytes[0] = I2C_ADDR\n            twoBytes[1] = reg\n            pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n            control.waitMicros(100) //time.sleep(0.0001);\n        }\n\n    read(reg: uint8) {\n        /* Read byte from the sensor. */\n        // return _bus.read_byte_data(_addr, reg);\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        return pins.i2cReadNumber(I2C_ADDR, NumberFormat.UInt8LE, false)\n    }\n\n    read_bytes(reg: uint8, length = 1) {\n        /* Read byte(s) from the sensor. */\n        // return _bus.read_i2c_block_data(_addr, reg, length);\n        let buf = pins.createBuffer(length)\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        buf = pins.i2cReadBuffer(I2C_ADDR, length, false)\n        return buf\n    }\n\n\n    selectBank(value: uint8) {\n        /* Switch register bank. */\n        if (!(this.registerBank == value)) {\n            this.write(ICM20948_BANK_SEL, value << 4);\n            this.registerBank = value;\n        }\n    }\n    trigger_mag_io() {\n        let user = this.read(ICM20948_USER_CTRL);\n        this.write(ICM20948_USER_CTRL, user | 0x20);\n        control.waitMicros(5000) //time.sleep(0.005);\n        this.write(ICM20948_USER_CTRL, user);\n    }\n\n\n    mag_write(reg: uint8, value: uint8) {\n        /* Write a byte to the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, value);\n        this.selectBank(0);\n        this.trigger_mag_io();\n    }\n\n    mag_read(reg: uint8) {\n        /* Read a byte from the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, 0xff);\n\n        this.selectBank(0);\n        this.trigger_mag_io();\n\n        return this.read(ICM20948_EXT_SLV_SENS_DATA_00);\n    }\n\n\n    mag_read_bytes(reg: uint8, length = 1) {\n        /* Read up to 24 bytes from the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, 0xff);\n        this.selectBank(0);\n        this.trigger_mag_io();\n\n        return this.read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n    }\n\n\n    magnetometer_ready() {\n        /* Check the magnetometer status ready bit. */\n        return (this.mag_read(AK09916_ST1) & 0x01) > 0;\n    }\n\n    read_magnetometer_data(timeout = 1.0) {\n        this.mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n        let t_start = control.millis()\n        while (!this.magnetometer_ready()) {\n            if (control.millis() - t_start > timeout) {\n                /////throw RuntimeError('Timeout waiting for Magnetometer Ready');\n                control.waitMicros(10) //time.sleep(0.00001);\n            }\n            let data = this.mag_read_bytes(AK09916_HXL, 6);\n        }\n        // Read ST2 to confirm read finished,\n        // needed for continuous modes\n        // mag_this.read(AK09916_ST2)\n\n        //////x, y, z = struct.unpack('<hhh', bytearray(data));\n        let x = 0\n        let y = 0\n        let z = 0\n\n        // Scale for magnetic flux density \"uT\"\n        // from section 3.3 of the datasheet\n        // This value is constant\n        x *= 0.15;\n        y *= 0.15;\n        z *= 0.15;\n\n        return x, y, z;\n    }\n    read_accelerometer_gyro_data() {\n        this.selectBank(0);\n        let data = this.read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n        //ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n        //dissect 12 bytes into 6 words\n        let ax = (data[0] << 8) + data[1]\n        let ay = (data[2] << 8) + data[3]\n        let az = (data[4] << 8) + data[5]\n        let gx = (data[6] << 8) + data[7]\n        let gy = (data[8] << 8) + data[9]\n        let gz = (data[10] << 8) + data[11]\n\n        this.selectBank(2);\n\n        // Read accelerometer full scale range and\n        // use it to compensate the reading to gs\n        let scale = (this.read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n        // scale ranges from section 3.2 of the datasheet\n        let gs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\n        ax /= gs;\n        ay /= gs;\n        az /= gs;\n\n        // Read back the degrees per second rate and\n        // use it to compensate the reading to dps\n        scale = (this.read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n        // scale ranges from section 3.1 of the datasheet\n        let dps = [131, 65.5, 32.8, 16.4][scale];\n\n        gx /= dps;\n        gy /= dps;\n        gz /= dps;\n\n        return ax, ay, az, gx, gy, gz;\n    }\n\n    set_accelerometer_sample_rate(rate = 125) {\n        /* Set the accelerometer sample rate in Hz. */\n        this.selectBank(2);\n        // 125Hz - 1.125 kHz / (1 + rate)\n        //rate = Number((1125.0 / rate) - 1);\n        rate = (1125.0 / rate) - 1;\n        // TODO maybe use struct to pack and then this.write_bytes\n        this.write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n        this.write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n    }\n\n    set_accelerometer_full_scale(scale = 16) {\n        /* Set the accelerometer fulls cale range to +- the supplied value. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n        ///////value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n        this.write(ICM20948_ACCEL_CONFIG, value);\n    }\n\n    set_accelerometer_low_pass(enabled = true, mode = 5) {\n        /* Configure the accelerometer low pass filter. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            this.write(ICM20948_ACCEL_CONFIG, value);\n        }\n    }\n\n    set_gyro_sample_rate(rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        this.selectBank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = (1125.0 / rate) - 1;\n        this.write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n\n    set_gyro_full_scale(scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        /////value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        this.write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    set_gyro_low_pass(enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n        }\n        value |= (mode & 0x07) << 4;\n        this.write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    read_temperature() {\n        /* Property to read the current IMU temperature */\n        // PWR_MGMT_1 defaults to leave temperature enabled\n        this.selectBank(0);\n        let temp_raw_bytes = this.read_bytes(ICM20948_TEMP_OUT_H, 2);\n        //let temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0];\n        let temp_raw = (temp_raw_bytes[0] << 8) + temp_raw_bytes[1]\n        let temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n        return temperature_deg_c;\n    }\n}\n}"},{"type":"added","filename":"ICM20948.ts","value":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\n//namespace ICM {\nconst CHIP_ID = 0xEA;\nconst ICM20948_BANK_SEL = 0x7f;\n\nconst ICM20948_NOT_FOUND = 222; // Panic code!\n\n\nconst ICM20948_I2C_MST_ODR_CONFIG = 0x00;\nconst ICM20948_I2C_MST_CTRL = 0x01;\nconst ICM20948_I2C_MST_DELAY_CTRL = 0x02;\nconst ICM20948_I2C_SLV0_ADDR = 0x03;\nconst ICM20948_I2C_SLV0_REG = 0x04;\nconst ICM20948_I2C_SLV0_CTRL = 0x05;\nconst ICM20948_I2C_SLV0_DO = 0x06;\nconst ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\nconst ICM20948_GYRO_SMPLRT_DIV = 0x00;\nconst ICM20948_GYRO_CONFIG_1 = 0x01;\nconst ICM20948_GYRO_CONFIG_2 = 0x02;\n\n// Bank 0\nconst ICM20948_WHO_AM_I = 0x00;\nconst ICM20948_USER_CTRL = 0x03;\nconst ICM20948_PWR_MGMT_1 = 0x06;\nconst ICM20948_PWR_MGMT_2 = 0x07;\nconst ICM20948_INT_PIN_CFG = 0x0F;\n\nconst ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\nconst ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\nconst ICM20948_ACCEL_INTEL_CTRL = 0x12;\nconst ICM20948_ACCEL_WOM_THR = 0x13;\nconst ICM20948_ACCEL_CONFIG = 0x14;\nconst ICM20948_ACCEL_XOUT_H = 0x2D;\nconst ICM20948_GRYO_XOUT_H = 0x33;\n\nconst ICM20948_TEMP_OUT_H = 0x39;\nconst ICM20948_TEMP_OUT_L = 0x3A;\n\n// Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nconst ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\nconst ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\nconst ICM20948_ROOM_TEMP_OFFSET = 21;\n\nconst AK09916_I2C_ADDR = 0x0c;\nconst AK09916_CHIP_ID = 0x09;\nconst AK09916_WIA = 0x01;\nconst AK09916_NOT_FOUND = 222; // Panic code!\n\nconst AK09916_ST1 = 0x10;\nconst AK09916_ST1_DOR = 0b00000010   // Data overflow bit\nconst AK09916_ST1_DRDY = 0b00000001  // Data ready bit\nconst AK09916_HXL = 0x11;\nconst AK09916_ST2 = 0x18;\nconst AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\nconst AK09916_CNTL2 = 0x31;\nconst AK09916_CNTL2_MODE = 0b00001111;\nconst AK09916_CNTL2_MODE_OFF = 0;\nconst AK09916_CNTL2_MODE_SINGLE = 1;\nconst AK09916_CNTL2_MODE_CONT1 = 2;\nconst AK09916_CNTL2_MODE_CONT2 = 4;\nconst AK09916_CNTL2_MODE_CONT3 = 6;\nconst AK09916_CNTL2_MODE_CONT4 = 8;\nconst AK09916_CNTL2_MODE_TEST = 16;\nconst AK09916_CNTL3 = 0x32;\n// GLOBALS\n\nclass ICM20948 {\n    registerBank: number\n    imuAddress: number\n\n    constructor(myAddress: number) {\n        this.registerBank = -1; // currently-selected register-bank\n        this.imuAddress = myAddress; // I2C master address of ICM20948\n\n        this.selectBank(0);\n        if (this.read(ICM20948_WHO_AM_I) != CHIP_ID) {\n            //throw RuntimeError('Unable to find ICM20948');\n            control.panic(ICM20948_NOT_FOUND)\n        }\n        this.write(ICM20948_PWR_MGMT_1, 0x80);\n        basic.pause(10) //time.sleep(0.01);\n        this.write(ICM20948_PWR_MGMT_1, 0x01);\n        this.write(ICM20948_PWR_MGMT_2, 0x00);\n\n        this.selectBank(2);\n\n        this.set_gyro_sample_rate(100);\n        this.set_gyro_low_pass(true, 5);\n        this.set_gyro_full_scale(250);\n\n        this.set_accelerometer_sample_rate(125);\n        this.set_accelerometer_low_pass(true, 5);\n        this.set_accelerometer_full_scale(16);\n\n        this.selectBank(0);\n        this.write(ICM20948_INT_PIN_CFG, 0x30);\n\n        this.selectBank(3);\n        this.write(ICM20948_I2C_MST_CTRL, 0x4D);\n        this.write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n        if (this.mag_read(AK09916_WIA) != AK09916_CHIP_ID) {\n            // throw RuntimeError('Unable to find AK09916');\n            control.panic(AK09916_NOT_FOUND)\n        }\n        // Reset the magnetometer\n        this.mag_write(AK09916_CNTL3, 0x01);\n        while (this.mag_read(AK09916_CNTL3) == 0x01) {\n            control.waitMicros(100) //time.sleep(0.0001);\n        }\n    }\n\n    write(reg: uint8, value: uint8) {\n        /* Write byte to the sensor. */\n        //_bus.this.write_byte_data(_addr, reg, value);\n\n        let twoBytes = pins.createBuffer(2)\n        twoBytes[0] = I2C_ADDR\n        twoBytes[1] = reg\n        pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n\n    read(reg: uint8) {\n        /* Read byte from the sensor. */\n        // return _bus.read_byte_data(_addr, reg);\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        return pins.i2cReadNumber(I2C_ADDR, NumberFormat.UInt8LE, false)\n    }\n\n    read_bytes(reg: uint8, length = 1) {\n        /* Read byte(s) from the sensor. */\n        // return _bus.read_i2c_block_data(_addr, reg, length);\n        let buf = pins.createBuffer(length)\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        buf = pins.i2cReadBuffer(I2C_ADDR, length, false)\n        return buf\n    }\n\n\n    selectBank(value: uint8) {\n        /* Switch register bank. */\n        if (!(this.registerBank == value)) {\n            this.write(ICM20948_BANK_SEL, value << 4);\n            this.registerBank = value;\n        }\n    }\n    trigger_mag_io() {\n        let user = this.read(ICM20948_USER_CTRL);\n        this.write(ICM20948_USER_CTRL, user | 0x20);\n        control.waitMicros(5000) //time.sleep(0.005);\n        this.write(ICM20948_USER_CTRL, user);\n    }\n\n\n    mag_write(reg: uint8, value: uint8) {\n        /* Write a byte to the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, value);\n        this.selectBank(0);\n        this.trigger_mag_io();\n    }\n\n    mag_read(reg: uint8) {\n        /* Read a byte from the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, 0xff);\n\n        this.selectBank(0);\n        this.trigger_mag_io();\n\n        return this.read(ICM20948_EXT_SLV_SENS_DATA_00);\n    }\n\n\n    mag_read_bytes(reg: uint8, length = 1) {\n        /* Read up to 24 bytes from the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, 0xff);\n        this.selectBank(0);\n        this.trigger_mag_io();\n\n        return this.read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n    }\n\n\n    magnetometer_ready() {\n        /* Check the magnetometer status ready bit. */\n        return (this.mag_read(AK09916_ST1) & 0x01) > 0;\n    }\n\n    read_magnetometer_data(timeout = 1.0) {\n        this.mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n        let t_start = control.millis()\n        while (!this.magnetometer_ready()) {\n            if (control.millis() - t_start > timeout) {\n                /////throw RuntimeError('Timeout waiting for Magnetometer Ready');\n                control.waitMicros(10) //time.sleep(0.00001);\n            }\n            let data = this.mag_read_bytes(AK09916_HXL, 6);\n        }\n        // Read ST2 to confirm read finished,\n        // needed for continuous modes\n        // mag_this.read(AK09916_ST2)\n\n        //////x, y, z = struct.unpack('<hhh', bytearray(data));\n        let x = 0\n        let y = 0\n        let z = 0\n\n        // Scale for magnetic flux density \"uT\"\n        // from section 3.3 of the datasheet\n        // This value is constant\n        x *= 0.15;\n        y *= 0.15;\n        z *= 0.15;\n\n        return x, y, z;\n    }\n    read_accelerometer_gyro_data() {\n        this.selectBank(0);\n        let data = this.read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n        //ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n        //dissect 12 bytes into 6 words\n        let ax = (data[0] << 8) + data[1]\n        let ay = (data[2] << 8) + data[3]\n        let az = (data[4] << 8) + data[5]\n        let gx = (data[6] << 8) + data[7]\n        let gy = (data[8] << 8) + data[9]\n        let gz = (data[10] << 8) + data[11]\n\n        this.selectBank(2);\n\n        // Read accelerometer full scale range and\n        // use it to compensate the reading to gs\n        let scale = (this.read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n        // scale ranges from section 3.2 of the datasheet\n        let gs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\n        ax /= gs;\n        ay /= gs;\n        az /= gs;\n\n        // Read back the degrees per second rate and\n        // use it to compensate the reading to dps\n        scale = (this.read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n        // scale ranges from section 3.1 of the datasheet\n        let dps = [131, 65.5, 32.8, 16.4][scale];\n\n        gx /= dps;\n        gy /= dps;\n        gz /= dps;\n\n        return ax, ay, az, gx, gy, gz;\n    }\n\n    set_accelerometer_sample_rate(rate = 125) {\n        /* Set the accelerometer sample rate in Hz. */\n        this.selectBank(2);\n        // 125Hz - 1.125 kHz / (1 + rate)\n        //rate = Number((1125.0 / rate) - 1);\n        rate = (1125.0 / rate) - 1;\n        // TODO maybe use struct to pack and then this.write_bytes\n        this.write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n        this.write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n    }\n\n    set_accelerometer_full_scale(scale = 16) {\n        /* Set the accelerometer fulls cale range to +- the supplied value. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n        ///////value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n        this.write(ICM20948_ACCEL_CONFIG, value);\n    }\n\n    set_accelerometer_low_pass(enabled = true, mode = 5) {\n        /* Configure the accelerometer low pass filter. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            this.write(ICM20948_ACCEL_CONFIG, value);\n        }\n    }\n\n    set_gyro_sample_rate(rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        this.selectBank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = (1125.0 / rate) - 1;\n        this.write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n\n    set_gyro_full_scale(scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        /////value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        this.write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    set_gyro_low_pass(enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n        }\n        value |= (mode & 0x07) << 4;\n        this.write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    read_temperature() {\n        /* Property to read the current IMU temperature */\n        // PWR_MGMT_1 defaults to leave temperature enabled\n        this.selectBank(0);\n        let temp_raw_bytes = this.read_bytes(ICM20948_TEMP_OUT_H, 2);\n        //let temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0];\n        let temp_raw = (temp_raw_bytes[0] << 8) + temp_raw_bytes[1]\n        let temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n        return temperature_deg_c;\n    }\n}\n"}]},{"timestamp":1760688724687,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"ICM20948.ts","patch":[{"start1":7170,"length1":17,"diffs":[[1,"        let x = 0\n"]]}]}]},{"timestamp":1760709477982,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"ICM20948.ts","patch":[{"start1":7170,"length1":19,"diffs":[[1,"        let x = \n"]]}]}]},{"timestamp":1760709480044,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"ICM20948.ts","patch":[{"start1":6652,"length1":24,"diffs":[[1,""]]},{"start1":6912,"length1":56,"diffs":[[1,"            let data = this.mag_read_bytes(AK09916_HXL, 6);\n"]]},{"start1":7170,"length1":55,"diffs":[[1,"        let x = ()\n"]]}]}]},{"timestamp":1760710070671,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":2440,"length1":27,"diffs":[[1,"let mag:number[] = []\nlet gyro: number[] = []\n"]]}]},{"type":"edited","filename":"ICM20948.ts","patch":[{"start1":3664,"length1":38,"diffs":[[1,"    write(reg: uint8, value: uint8) {\n"]]},{"start1":4016,"length1":24,"diffs":[[1,"    read(reg: uint8) {\n"]]},{"start1":4276,"length1":42,"diffs":[[1,"    read_bytes(reg: uint8, length = 1) {\n"]]},{"start1":4619,"length1":32,"diffs":[[1,"    selectBank(value: uint8) {\n"]]},{"start1":5075,"length1":44,"diffs":[[1,"    mag_write(reg: uint8, value: uint8) {\n"]]},{"start1":5442,"length1":28,"diffs":[[1,"    mag_read(reg: uint8) {\n"]]},{"start1":5843,"length1":46,"diffs":[[1,"    mag_read_bytes(reg: uint8, length = 1) {\n"]]},{"start1":7190,"length1":171,"diffs":[[1,"        let x = data.getNumber(NumberFormat.Unt16LE,0)\n        let y = 0\n        let z = 0\n"]]},{"start1":7467,"length1":26,"diffs":[[1,"        return x, y, z;\n"]]},{"start1":7743,"length1":349,"diffs":[[1,"        let ax = (data[0] << 8) + data[1]\n        let ay = (data[2] << 8) + data[3]\n        let az = (data[4] << 8) + data[5]\n        let gx = (data[6] << 8) + data[7]\n        let gy = (data[8] << 8) + data[9]\n        let gz = (data[10] << 8) + data[11]\n"]]},{"start1":8707,"length1":41,"diffs":[[1,"        return ax, ay, az, gx, gy, gz;\n"]]}]}]},{"timestamp":1760710523473,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1,"length1":0,"diffs":[[1,"\nconst I2C_ADDR = 0x68;\nconst I2C_ADDR_ALT = 0x69;\n/*\nconst I2C_ADDR_ALT = 0x69;\nconst ICM20948_BANK_SEL = 0x7f;\n\nconst ICM20948_I2C_MST_ODR_CONFIG = 0x00;\nconst ICM20948_I2C_MST_CTRL = 0x01;\nconst ICM20948_I2C_MST_DELAY_CTRL = 0x02;\nconst ICM20948_I2C_SLV0_ADDR = 0x03;\nconst ICM20948_I2C_SLV0_REG = 0x04;\nconst ICM20948_I2C_SLV0_CTRL = 0x05;\nconst ICM20948_I2C_SLV0_DO = 0x06;\nconst ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\nconst ICM20948_GYRO_SMPLRT_DIV = 0x00;\nconst ICM20948_GYRO_CONFIG_1 = 0x01;\nconst ICM20948_GYRO_CONFIG_2 = 0x02;\n\n// Bank 0\nconst ICM20948_WHO_AM_I = 0x00;\nconst ICM20948_USER_CTRL = 0x03;\nconst ICM20948_PWR_MGMT_1 = 0x06;\nconst ICM20948_PWR_MGMT_2 = 0x07;\nconst ICM20948_INT_PIN_CFG = 0x0F;\n\nconst ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\nconst ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\nconst ICM20948_ACCEL_INTEL_CTRL = 0x12;\nconst ICM20948_ACCEL_WOM_THR = 0x13;\nconst ICM20948_ACCEL_CONFIG = 0x14;\nconst ICM20948_ACCEL_XOUT_H = 0x2D;\nconst ICM20948_GRYO_XOUT_H = 0x33;\n\nconst ICM20948_TEMP_OUT_H = 0x39;\nconst ICM20948_TEMP_OUT_L = 0x3A;\n\n// Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nconst ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\nconst ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\nconst ICM20948_ROOM_TEMP_OFFSET = 21;\n\nconst AK09916_I2C_ADDR = 0x0c;\nconst AK09916_CHIP_ID = 0x09;\nconst AK09916_WIA = 0x01;\nconst AK09916_ST1 = 0x10;\nconst AK09916_ST1_DOR = 0b00000010   // Data overflow bit\nconst AK09916_ST1_DRDY = 0b00000001  // Data ready bit\nconst AK09916_HXL = 0x11;\nconst AK09916_ST2 = 0x18;\nconst AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\nconst AK09916_CNTL2 = 0x31;\nconst AK09916_CNTL2_MODE = 0b00001111;\nconst AK09916_CNTL2_MODE_OFF = 0;\nconst AK09916_CNTL2_MODE_SINGLE = 1;\nconst AK09916_CNTL2_MODE_CONT1 = 2;\nconst AK09916_CNTL2_MODE_CONT2 = 4;\nconst AK09916_CNTL2_MODE_CONT3 = 6;\nconst AK09916_CNTL2_MODE_CONT4 = 8;\nconst AK09916_CNTL2_MODE_TEST = 16;\nconst AK09916_CNTL3 = 0x32;\n\n\nlet twoBytes = pins.createBuffer(2)\npins.i2cWriteBuffer(I2C_ADDR,twoBytes,false)\n\n// try addressing the IMU\ndatalogger.mirrorToSerial(true)\ndatalogger.log(datalogger.createCV(\"startup\", 12345))\npins.i2cWriteNumber(I2C_ADDR, ICM20948_WHO_AM_I,NumberFormat.UInt8LE)\nlet me = pins.i2cReadNumber(I2C_ADDR,NumberFormat.UInt8LE,false)\ndatalogger.log(datalogger.createCV(\"me\", me))\n\npins.i2cWriteBuffer(I2C_ADDR,buffer,false)\n*/\nlet imu = new ICM20948(I2C_ADDR)\n\nlet mag = []\nlet gyro = []\nwhile (true) {\n    mag = imu.read_magnetometer_data();\n    gyro = imu.read_accelerometer_gyro_data();\n\n    datalogger.log(\n        datalogger.createCV(\"Mag_X\", mag[0]),\n        datalogger.createCV(\"Mag_Y\", mag[1]),\n        datalogger.createCV(\"Mag_Z\", mag[2]),\n        datalogger.createCV(\"Accel_X\", gyro[0]),\n        datalogger.createCV(\"Accel_Y\", gyro[1]),\n        datalogger.createCV(\"Accel_Z\", gyro[2]),\n        datalogger.createCV(\"Spin_X\", gyro[3]),\n        datalogger.createCV(\"Spin_X\", gyro[4]),\n        datalogger.createCV(\"Spin_X\", gyro[5])\n    )\n}\n    /*\n//Accel: {ax:05.2f} {ay:05.2f} {az:05.2f}\n//Gyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\n//Mag:   {x:05.2f} {y:05.2f} {z:05.2f}\n\nbasic.pause(250) //time.sleep(0.25)\n*/\n"]]}]},{"type":"edited","filename":"ICM20948.ts","patch":[{"start1":1477,"length1":46,"diffs":[[1,"const AK09916_NOT_FOUND = 222; // Panic code!\n"]]}]}]},{"timestamp":1760711118770,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":182,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":33,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":252,"length1":0,"diffs":[[1,"        \"main.py\",\n"]]}]},{"type":"edited","filename":"ICM20948.ts","patch":[{"start1":2184,"length1":23,"diffs":[[1,"    imuAddress: number\n"]]},{"start1":2313,"length1":71,"diffs":[[1,"        this.imuAddress = myAddress; // I2C master address of ICM20948\n"]]},{"start1":3843,"length1":38,"diffs":[[1,"        twoBytes[0] = I2C_ADDR\n"]]},{"start1":3900,"length1":62,"diffs":[[1,"        pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n"]]},{"start1":4132,"length1":152,"diffs":[[1,"        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        return pins.i2cReadNumber(I2C_ADDR, NumberFormat.UInt8LE, false)\n"]]},{"start1":4471,"length1":137,"diffs":[[1,"        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        buf = pins.i2cReadBuffer(I2C_ADDR, length, false)\n"]]}]},{"type":"removed","filename":"main.py","value":""}]},{"timestamp":1760711693938,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":585,"diffs":[[1,"basic.forever(function () {\n\t\n})\n"]]}]}]},{"timestamp":1760712293846,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block><block type=\"device_forever\" x=\"205\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":26,"length1":116,"diffs":[[1,"let sensor = new ICM20948(ICM_ADDRESS)datalogger.mirrorToSerial(false)\nlet mag = []\nlet gyro = []\n"]]},{"start1":208,"length1":481,"diffs":[[1,""]]},{"start1":209,"length1":3,"diffs":[[1,"\ndatalogger.log(\n    datalogger.createCV('mx', mag[0]),\n    datalogger.createCV('my', mag[1]),\n    datalogger.createCV('mz', mag[2]),\n    datalogger.createCV('gx', gyro[0]),\n    datalogger.createCV('gy', gyro[1]),\n    datalogger.createCV('gz', gyro[2]),\n    datalogger.createCV('sx', gyro[3]),\n    datalogger.createCV('sy', gyro[4]),\n    datalogger.createCV('sz', gyro[5])\n)\n\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":32,"diffs":[[1,"    \"name\": \"test_ims\",\n"]]},{"start1":306,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1760529402457,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"test_i2c\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1760537185972,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"","README.md":"","main.py":"pins.i2c_read_number(0, NumberFormat.INT8_LE, False)\npins.i2c_write_number(0, 0, NumberFormat.INT8_LE, False)\n","pins_extra.ts":"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"\"\nnamespace custom {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n    }\n\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n    }\n}\n","pxt.json":"{\n    \"name\": \"test_i2c\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\",\n        \"pins_extra.ts\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1760615593079,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n\nconst CHIP_ID = 0xEA;\nconst I2C_ADDR = 0x68;\nconst I2C_ADDR_ALT = 0x69;\nconst ICM20948_BANK_SEL = 0x7f;\n\nconst ICM20948_I2C_MST_ODR_CONFIG = 0x00;\nconst ICM20948_I2C_MST_CTRL = 0x01;\nconst ICM20948_I2C_MST_DELAY_CTRL = 0x02;\nconst ICM20948_I2C_SLV0_ADDR = 0x03;\nconst ICM20948_I2C_SLV0_REG = 0x04;\nconst ICM20948_I2C_SLV0_CTRL = 0x05;\nconst ICM20948_I2C_SLV0_DO = 0x06;\nconst ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\nconst ICM20948_GYRO_SMPLRT_DIV = 0x00;\nconst ICM20948_GYRO_CONFIG_1 = 0x01;\nconst ICM20948_GYRO_CONFIG_2 = 0x02;\n\n// Bank 0\nconst ICM20948_WHO_AM_I = 0x00;\nconst ICM20948_USER_CTRL = 0x03;\nconst ICM20948_PWR_MGMT_1 = 0x06;\nconst ICM20948_PWR_MGMT_2 = 0x07;\nconst ICM20948_INT_PIN_CFG = 0x0F;\n\nconst ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\nconst ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\nconst ICM20948_ACCEL_INTEL_CTRL = 0x12;\nconst ICM20948_ACCEL_WOM_THR = 0x13;\nconst ICM20948_ACCEL_CONFIG = 0x14;\nconst ICM20948_ACCEL_XOUT_H = 0x2D;\nconst ICM20948_GRYO_XOUT_H = 0x33;\n\nconst ICM20948_TEMP_OUT_H = 0x39;\nconst ICM20948_TEMP_OUT_L = 0x3A;\n\n// Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nconst ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\nconst ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\nconst ICM20948_ROOM_TEMP_OFFSET = 21;\n\nconst AK09916_I2C_ADDR = 0x0c;\nconst AK09916_CHIP_ID = 0x09;\nconst AK09916_WIA = 0x01;\nconst AK09916_ST1 = 0x10;\nconst AK09916_ST1_DOR = 0b00000010   // Data overflow bit\nconst AK09916_ST1_DRDY = 0b00000001  // Data ready bit\nconst AK09916_HXL = 0x11;\nconst AK09916_ST2 = 0x18;\nconst AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\nconst AK09916_CNTL2 = 0x31;\nconst AK09916_CNTL2_MODE = 0b00001111;\nconst AK09916_CNTL2_MODE_OFF = 0;\nconst AK09916_CNTL2_MODE_SINGLE = 1;\nconst AK09916_CNTL2_MODE_CONT1 = 2;\nconst AK09916_CNTL2_MODE_CONT2 = 4;\nconst AK09916_CNTL2_MODE_CONT3 = 6;\nconst AK09916_CNTL2_MODE_CONT4 = 8;\nconst AK09916_CNTL2_MODE_TEST = 16;\nconst AK09916_CNTL3 = 0x32;\nlet twoBytes = pins.createBuffer(2)\npins.i2cWriteBuffer(I2C_ADDR,twoBytes,false)\n// try addressing the IMU\ndatalogger.mirrorToSerial(true)\ndatalogger.log(datalogger.createCV(\"startup\", 12345))\npins.i2cWriteNumber(I2C_ADDR, ICM20948_WHO_AM_I,NumberFormat.UInt8LE)\nlet me = pins.i2cReadNumber(I2C_ADDR,NumberFormat.UInt8LE,false)\ndatalogger.log(datalogger.createCV(\"me\", me))\n\npins.i2cWriteBuffer(I2C_ADDR,buffer,false)","README.md":"","main.py":"","pins_extra.ts":"/*\nfunction fetch_byte_reg(address: number, byte_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, byte_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Ubyte(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int8LE, false))\n}\ncontrol.waitMicros(4)\n*/\n\n/*\nfunction fetch_word_reg(word_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, word_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Uword(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int16BE, false))\n}\n*/\n/*\nfunction getreg(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt8BE);\n}\n*/\n\n/*\nfunction getInt8LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int8LE);\n}\n*/\n\n/*\nfunction getUInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt16LE);\n}\n*/\n\n/*\nfunction getInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int16LE);\n}\n*/","LCM20948.ts":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\nnamespace ICM {\n\n    const CHIP_ID = 0xEA;\n    const I2C_ADDR = 0x68;\n    const I2C_ADDR_ALT = 0x69;\n    const ICM20948_BANK_SEL = 0x7f;\n\n    const ICM20948_I2C_MST_ODR_CONFIG = 0x00;\n    const ICM20948_I2C_MST_CTRL = 0x01;\n    const ICM20948_I2C_MST_DELAY_CTRL = 0x02;\n    const ICM20948_I2C_SLV0_ADDR = 0x03;\n    const ICM20948_I2C_SLV0_REG = 0x04;\n    const ICM20948_I2C_SLV0_CTRL = 0x05;\n    const ICM20948_I2C_SLV0_DO = 0x06;\n    const ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\n    const ICM20948_GYRO_SMPLRT_DIV = 0x00;\n    const ICM20948_GYRO_CONFIG_1 = 0x01;\n    const ICM20948_GYRO_CONFIG_2 = 0x02;\n\n    // Bank 0\n    const ICM20948_WHO_AM_I = 0x00;\n    const ICM20948_USER_CTRL = 0x03;\n    const ICM20948_PWR_MGMT_1 = 0x06;\n    const ICM20948_PWR_MGMT_2 = 0x07;\n    const ICM20948_INT_PIN_CFG = 0x0F;\n\n    const ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\n    const ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\n    const ICM20948_ACCEL_INTEL_CTRL = 0x12;\n    const ICM20948_ACCEL_WOM_THR = 0x13;\n    const ICM20948_ACCEL_CONFIG = 0x14;\n    const ICM20948_ACCEL_XOUT_H = 0x2D;\n    const ICM20948_GRYO_XOUT_H = 0x33;\n\n    const ICM20948_TEMP_OUT_H = 0x39;\n    const ICM20948_TEMP_OUT_L = 0x3A;\n\n    // Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\n    const ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\n    const ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\n    const ICM20948_ROOM_TEMP_OFFSET = 21;\n\n    const AK09916_I2C_ADDR = 0x0c;\n    const AK09916_CHIP_ID = 0x09;\n    const AK09916_WIA = 0x01;\n    const AK09916_ST1 = 0x10;\n    const AK09916_ST1_DOR = 0b00000010   // Data overflow bit\n    const AK09916_ST1_DRDY = 0b00000001  // Data ready bit\n    const AK09916_HXL = 0x11;\n    const AK09916_ST2 = 0x18;\n    const AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\n    const AK09916_CNTL2 = 0x31;\n    const AK09916_CNTL2_MODE = 0b00001111;\n    const AK09916_CNTL2_MODE_OFF = 0;\n    const AK09916_CNTL2_MODE_SINGLE = 1;\n    const AK09916_CNTL2_MODE_CONT1 = 2;\n    const AK09916_CNTL2_MODE_CONT2 = 4;\n    const AK09916_CNTL2_MODE_CONT3 = 6;\n    const AK09916_CNTL2_MODE_CONT4 = 8;\n    const AK09916_CNTL2_MODE_TEST = 16;\n    const AK09916_CNTL3 = 0x32;\n\n    // GLOBALS\n    let _bank = -1 // currently-selected register-bank\n\n\n    function write(reg:uint8, value:uint8) {\n        /* Write byte to the sensor. */\n        //_bus.write_byte_data(_addr, reg, value);\n\n        let twoBytes = pins.createBuffer(2)\n        twoBytes[0] = I2C_ADDR\n        twoBytes[1] = reg\n        pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n    function read(reg: uint8) {\n        /* Read byte from the sensor. */\n        // return _bus.read_byte_data(_addr, reg);\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        return pins.i2cReadNumber(I2C_ADDR, NumberFormat.UInt8LE, false)\n    }\n\n    function read_bytes(reg: uint8, length = 1) {\n        /* Read byte(s) from the sensor. */\n        // return _bus.read_i2c_block_data(_addr, reg, length);\n        let buf = pins.createBuffer(length)\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        buf = pins.i2cReadBuffer(I2C_ADDR, length, false)\n        return buf\n    }\n\n\n    function selectBank(value: uint8) {\n        /* Switch register bank. */\n        if (!(_bank == value)) {\n            write(ICM20948_BANK_SEL, value << 4);\n            _bank = value;\n        }\n    }\n    function trigger_mag_io() {\n        let user = read(ICM20948_USER_CTRL);\n        write(ICM20948_USER_CTRL, user | 0x20);\n        control.waitMicros(5000) //time.sleep(0.005);\n        write(ICM20948_USER_CTRL, user);\n    }\n\n\n    function mag_write(reg: uint8, value: uint8) {\n        /* Write a byte to the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, value);\n        selectBank(0);\n        trigger_mag_io();\n    }\n    function mag_read(reg: uint8) {\n        /* Read a byte from the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, 0xff);\n\n        selectBank(0);\n        trigger_mag_io();\n\n        return read(ICM20948_EXT_SLV_SENS_DATA_00);\n    }\n\n    function mag_read_bytes(reg: uint8, length = 1) {\n    /* Read up to 24 bytes from the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, 0xff);\n        selectBank(0);\n        trigger_mag_io();\n\n        return read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n    }\n\n    function magnetometer_ready() {\n        /* Check the magnetometer status ready bit. */\n        return (mag_read(AK09916_ST1) & 0x01) > 0;\n    }\n    function read_magnetometer_data(timeout = 1.0) {\n        mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n        let t_start = control.millis()\n        while (!magnetometer_ready()) {\n            if (control.millis() - t_start > timeout) {\n                /////throw RuntimeError('Timeout waiting for Magnetometer Ready');\n                control.waitMicros(10) //time.sleep(0.00001);\n            }\n            let data = mag_read_bytes(AK09916_HXL, 6);\n        }\n        // Read ST2 to confirm read finished,\n        // needed for continuous modes\n        // mag_read(AK09916_ST2)\n\n        //////x, y, z = struct.unpack('<hhh', bytearray(data));\n\n        // Scale for magnetic flux density \"uT\"\n        // from section 3.3 of the datasheet\n        // This value is constant\n        x *= 0.15;\n        y *= 0.15;\n        z *= 0.15;\n\n        return x, y, z;\n    }\n\n    function read_accelerometer_gyro_data() {\n        selectBank(0);\n        let data = read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n        \n        ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n\n        selectBank(2);\n\n        // Read accelerometer full scale range and\n        // use it to compensate the reading to gs\n        scale = (read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n        // scale ranges from section 3.2 of the datasheet\n        gs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\n        ax /= gs;\n        ay /= gs;\n        az /= gs;\n\n        // Read back the degrees per second rate and\n        // use it to compensate the reading to dps\n        scale = (read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n        // scale ranges from section 3.1 of the datasheet\n        dps = [131, 65.5, 32.8, 16.4][scale];\n\n        gx /= dps;\n        gy /= dps;\n        gz /= dps;\n\n        return ax, ay, az, gx, gy, gz;\n    }\n\n    function set_accelerometer_sample_rate(rate = 125) {\n        /* Set the accelerometer sample rate in Hz. */\n        selectBank(2);\n        // 125Hz - 1.125 kHz / (1 + rate)\n        //rate = Number((1125.0 / rate) - 1);\n        rate = (1125.0 / rate) - 1;\n        // TODO maybe use struct to pack and then write_bytes\n        write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n        write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n    }\n    function set_accelerometer_full_scale(scale = 16) {\n        /* Set the accelerometer fulls cale range to +- the supplied value. */\n        selectBank(2);\n        let value = read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n        ///////value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n        write(ICM20948_ACCEL_CONFIG, value);\n    }\n    function set_accelerometer_low_pass(enabled = true, mode = 5) {\n        /* Configure the accelerometer low pass filter. */\n        selectBank(2);\n        let value = read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            write(ICM20948_ACCEL_CONFIG, value);\n        }\n    }\n    function set_gyro_sample_rate(rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        selectBank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = (1125.0 / rate) - 1;\n        write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n    function set_gyro_full_scale(scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        selectBank(2);\n        let value = read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        /////value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        write(ICM20948_GYRO_CONFIG_1, value);\n    }\n    function set_gyro_low_pass(enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        selectBank(2);\n        let value = read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n        }\n        value |= (mode & 0x07) << 4;\n        write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    function read_temperature() {\n        /* Property to read the current IMU temperature */\n        // PWR_MGMT_1 defaults to leave temperature enabled\n        selectBank(0);\n        let temp_raw_bytes = read_bytes(ICM20948_TEMP_OUT_H, 2);\n        let temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0];\n        let temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n        return temperature_deg_c;\n    }\n\n    function initLcm20948(i2c_addr = I2C_ADDR, i2c_bus = null) {\n        _bank = -1;\n        _addr = i2c_addr;\n        /*\n            if (i2c_bus === null) {\n                from smbus2 var SMBus = require('SMBus');\n                _bus = SMBus(1);\n            } else {\n                _bus = i2c_bus;\n            }\n        */\n    }\n    selectBank(0);\n    if (!read(ICM20948_WHO_AM_I) == CHIP_ID) {\n        throw RuntimeError('Unable to find ICM20948');\n    }\n    write(ICM20948_PWR_MGMT_1, 0x80);\n    basic.pause(10) //time.sleep(0.01);\n    write(ICM20948_PWR_MGMT_1, 0x01);\n    write(ICM20948_PWR_MGMT_2, 0x00);\n\n    selectBank(2);\n\n    set_gyro_sample_rate(100);\n    set_gyro_low_pass(enabled = true, mode = 5);\n    set_gyro_full_scale(250);\n\n    set_accelerometer_sample_rate(125);\n    set_accelerometer_low_pass(enabled = true, mode = 5);\n    set_accelerometer_full_scale(16);\n\n    selectBank(0);\n    write(ICM20948_INT_PIN_CFG, 0x30);\n\n    selectBank(3);\n    write(ICM20948_I2C_MST_CTRL, 0x4D);\n    write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n    if (!mag_read(AK09916_WIA) == AK09916_CHIP_ID) {\n        throw RuntimeError('Unable to find AK09916');\n    }\n    // Reset the magnetometer\n    mag_write(AK09916_CNTL3, 0x01);\n    while (mag_read(AK09916_CNTL3) == 0x01) {\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n\n}\n    /*\n    if (__name__ == '__main__') {\n        imu = ICM20948();\n    }\n        while (true) {\n            x, y, z = imu.read_magnetometer_data();\n            ax, ay, az, gx, gy, gz = imu.read_accelerometer_gyro_data();\n        }\n            Logger.log(x,y,z,ax,ay,az,gx,gy,gz)\n            /*\n    //Accel: {ax:05.2f} {ay:05.2f} {az:05.2f}\n    //Gyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\n    //Mag:   {x:05.2f} {y:05.2f} {z:05.2f} \n\n    basic.pause(250) //time.sleep(0.25)\n        */\n","pxt.json":"{\n    \"name\": \"test_i2c\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\",\n        \"pins_extra.ts\",\n        \"LCM20948.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1760629243909,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n\nconst CHIP_ID = 0xEA;\nconst I2C_ADDR = 0x68;\nconst I2C_ADDR_ALT = 0x69;\nconst ICM20948_BANK_SEL = 0x7f;\n\nconst ICM20948_I2C_MST_ODR_CONFIG = 0x00;\nconst ICM20948_I2C_MST_CTRL = 0x01;\nconst ICM20948_I2C_MST_DELAY_CTRL = 0x02;\nconst ICM20948_I2C_SLV0_ADDR = 0x03;\nconst ICM20948_I2C_SLV0_REG = 0x04;\nconst ICM20948_I2C_SLV0_CTRL = 0x05;\nconst ICM20948_I2C_SLV0_DO = 0x06;\nconst ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\nconst ICM20948_GYRO_SMPLRT_DIV = 0x00;\nconst ICM20948_GYRO_CONFIG_1 = 0x01;\nconst ICM20948_GYRO_CONFIG_2 = 0x02;\n\n// Bank 0\nconst ICM20948_WHO_AM_I = 0x00;\nconst ICM20948_USER_CTRL = 0x03;\nconst ICM20948_PWR_MGMT_1 = 0x06;\nconst ICM20948_PWR_MGMT_2 = 0x07;\nconst ICM20948_INT_PIN_CFG = 0x0F;\n\nconst ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\nconst ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\nconst ICM20948_ACCEL_INTEL_CTRL = 0x12;\nconst ICM20948_ACCEL_WOM_THR = 0x13;\nconst ICM20948_ACCEL_CONFIG = 0x14;\nconst ICM20948_ACCEL_XOUT_H = 0x2D;\nconst ICM20948_GRYO_XOUT_H = 0x33;\n\nconst ICM20948_TEMP_OUT_H = 0x39;\nconst ICM20948_TEMP_OUT_L = 0x3A;\n\n// Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nconst ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\nconst ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\nconst ICM20948_ROOM_TEMP_OFFSET = 21;\n\nconst AK09916_I2C_ADDR = 0x0c;\nconst AK09916_CHIP_ID = 0x09;\nconst AK09916_WIA = 0x01;\nconst AK09916_ST1 = 0x10;\nconst AK09916_ST1_DOR = 0b00000010   // Data overflow bit\nconst AK09916_ST1_DRDY = 0b00000001  // Data ready bit\nconst AK09916_HXL = 0x11;\nconst AK09916_ST2 = 0x18;\nconst AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\nconst AK09916_CNTL2 = 0x31;\nconst AK09916_CNTL2_MODE = 0b00001111;\nconst AK09916_CNTL2_MODE_OFF = 0;\nconst AK09916_CNTL2_MODE_SINGLE = 1;\nconst AK09916_CNTL2_MODE_CONT1 = 2;\nconst AK09916_CNTL2_MODE_CONT2 = 4;\nconst AK09916_CNTL2_MODE_CONT3 = 6;\nconst AK09916_CNTL2_MODE_CONT4 = 8;\nconst AK09916_CNTL2_MODE_TEST = 16;\nconst AK09916_CNTL3 = 0x32;\nlet twoBytes = pins.createBuffer(2)\npins.i2cWriteBuffer(I2C_ADDR,twoBytes,false)\n// try addressing the IMU\ndatalogger.mirrorToSerial(true)\ndatalogger.log(datalogger.createCV(\"startup\", 12345))\npins.i2cWriteNumber(I2C_ADDR, ICM20948_WHO_AM_I,NumberFormat.UInt8LE)\nlet me = pins.i2cReadNumber(I2C_ADDR,NumberFormat.UInt8LE,false)\ndatalogger.log(datalogger.createCV(\"me\", me))\n\npins.i2cWriteBuffer(I2C_ADDR,buffer,false)","README.md":"","main.py":"","pins_extra.ts":"/*\nfunction fetch_byte_reg(address: number, byte_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, byte_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Ubyte(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int8LE, false))\n}\ncontrol.waitMicros(4)\n*/\n\n/*\nfunction fetch_word_reg(word_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, word_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Uword(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int16BE, false))\n}\n*/\n/*\nfunction getreg(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt8BE);\n}\n*/\n\n/*\nfunction getInt8LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int8LE);\n}\n*/\n\n/*\nfunction getUInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt16LE);\n}\n*/\n\n/*\nfunction getInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int16LE);\n}\n*/","LCM20948.ts":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\nnamespace ICM {\n\n    const CHIP_ID = 0xEA;\n    const I2C_ADDR = 0x68;\n    const I2C_ADDR_ALT = 0x69;\n    const ICM20948_BANK_SEL = 0x7f;\n\n    const ICM20948_I2C_MST_ODR_CONFIG = 0x00;\n    const ICM20948_I2C_MST_CTRL = 0x01;\n    const ICM20948_I2C_MST_DELAY_CTRL = 0x02;\n    const ICM20948_I2C_SLV0_ADDR = 0x03;\n    const ICM20948_I2C_SLV0_REG = 0x04;\n    const ICM20948_I2C_SLV0_CTRL = 0x05;\n    const ICM20948_I2C_SLV0_DO = 0x06;\n    const ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\n    const ICM20948_GYRO_SMPLRT_DIV = 0x00;\n    const ICM20948_GYRO_CONFIG_1 = 0x01;\n    const ICM20948_GYRO_CONFIG_2 = 0x02;\n\n    // Bank 0\n    const ICM20948_WHO_AM_I = 0x00;\n    const ICM20948_USER_CTRL = 0x03;\n    const ICM20948_PWR_MGMT_1 = 0x06;\n    const ICM20948_PWR_MGMT_2 = 0x07;\n    const ICM20948_INT_PIN_CFG = 0x0F;\n\n    const ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\n    const ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\n    const ICM20948_ACCEL_INTEL_CTRL = 0x12;\n    const ICM20948_ACCEL_WOM_THR = 0x13;\n    const ICM20948_ACCEL_CONFIG = 0x14;\n    const ICM20948_ACCEL_XOUT_H = 0x2D;\n    const ICM20948_GRYO_XOUT_H = 0x33;\n\n    const ICM20948_TEMP_OUT_H = 0x39;\n    const ICM20948_TEMP_OUT_L = 0x3A;\n\n    // Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\n    const ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\n    const ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\n    const ICM20948_ROOM_TEMP_OFFSET = 21;\n\n    const AK09916_I2C_ADDR = 0x0c;\n    const AK09916_CHIP_ID = 0x09;\n    const AK09916_WIA = 0x01;\n    const AK09916_ST1 = 0x10;\n    const AK09916_ST1_DOR = 0b00000010   // Data overflow bit\n    const AK09916_ST1_DRDY = 0b00000001  // Data ready bit\n    const AK09916_HXL = 0x11;\n    const AK09916_ST2 = 0x18;\n    const AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\n    const AK09916_CNTL2 = 0x31;\n    const AK09916_CNTL2_MODE = 0b00001111;\n    const AK09916_CNTL2_MODE_OFF = 0;\n    const AK09916_CNTL2_MODE_SINGLE = 1;\n    const AK09916_CNTL2_MODE_CONT1 = 2;\n    const AK09916_CNTL2_MODE_CONT2 = 4;\n    const AK09916_CNTL2_MODE_CONT3 = 6;\n    const AK09916_CNTL2_MODE_CONT4 = 8;\n    const AK09916_CNTL2_MODE_TEST = 16;\n    const AK09916_CNTL3 = 0x32;\n\n    // GLOBALS\n    let _bank = -1 // currently-selected register-bank\n\n\n    function write(reg:uint8, value:uint8) {\n        /* Write byte to the sensor. */\n        //_bus.write_byte_data(_addr, reg, value);\n\n        let twoBytes = pins.createBuffer(2)\n        twoBytes[0] = I2C_ADDR\n        twoBytes[1] = reg\n        pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n    function read(reg: uint8) {\n        /* Read byte from the sensor. */\n        // return _bus.read_byte_data(_addr, reg);\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        return pins.i2cReadNumber(I2C_ADDR, NumberFormat.UInt8LE, false)\n    }\n\n    function read_bytes(reg: uint8, length = 1) {\n        /* Read byte(s) from the sensor. */\n        // return _bus.read_i2c_block_data(_addr, reg, length);\n        let buf = pins.createBuffer(length)\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        buf = pins.i2cReadBuffer(I2C_ADDR, length, false)\n        return buf\n    }\n\n\n    function selectBank(value: uint8) {\n        /* Switch register bank. */\n        if (!(_bank == value)) {\n            write(ICM20948_BANK_SEL, value << 4);\n            _bank = value;\n        }\n    }\n    function trigger_mag_io() {\n        let user = read(ICM20948_USER_CTRL);\n        write(ICM20948_USER_CTRL, user | 0x20);\n        control.waitMicros(5000) //time.sleep(0.005);\n        write(ICM20948_USER_CTRL, user);\n    }\n\n\n    function mag_write(reg: uint8, value: uint8) {\n        /* Write a byte to the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, value);\n        selectBank(0);\n        trigger_mag_io();\n    }\n    function mag_read(reg: uint8) {\n        /* Read a byte from the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, 0xff);\n\n        selectBank(0);\n        trigger_mag_io();\n\n        return read(ICM20948_EXT_SLV_SENS_DATA_00);\n    }\n\n    function mag_read_bytes(reg: uint8, length = 1) {\n    /* Read up to 24 bytes from the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, 0xff);\n        selectBank(0);\n        trigger_mag_io();\n\n        return read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n    }\n\n    function magnetometer_ready() {\n        /* Check the magnetometer status ready bit. */\n        return (mag_read(AK09916_ST1) & 0x01) > 0;\n    }\n    function read_magnetometer_data(timeout = 1.0) {\n        mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n        let t_start = control.millis()\n        while (!magnetometer_ready()) {\n            if (control.millis() - t_start > timeout) {\n                /////throw RuntimeError('Timeout waiting for Magnetometer Ready');\n                control.waitMicros(10) //time.sleep(0.00001);\n            }\n            let data = mag_read_bytes(AK09916_HXL, 6);\n        }\n        // Read ST2 to confirm read finished,\n        // needed for continuous modes\n        // mag_read(AK09916_ST2)\n\n        //////x, y, z = struct.unpack('<hhh', bytearray(data));\n        let x = 0\n        let y = 0\n        let z = 0\n\n        // Scale for magnetic flux density \"uT\"\n        // from section 3.3 of the datasheet\n        // This value is constant\n        x *= 0.15;\n        y *= 0.15;\n        z *= 0.15;\n\n        return x, y, z;\n    }\n\n    function read_accelerometer_gyro_data() {\n        selectBank(0);\n        let data = read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n        \n        //ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n\n        selectBank(2);\n\n        // Read accelerometer full scale range and\n        // use it to compensate the reading to gs\n        scale = (read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n        // scale ranges from section 3.2 of the datasheet\n        gs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\n        ax /= gs;\n        ay /= gs;\n        az /= gs;\n\n        // Read back the degrees per second rate and\n        // use it to compensate the reading to dps\n        scale = (read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n        // scale ranges from section 3.1 of the datasheet\n        dps = [131, 65.5, 32.8, 16.4][scale];\n\n        gx /= dps;\n        gy /= dps;\n        gz /= dps;\n\n        return ax, ay, az, gx, gy, gz;\n    }\n\n    function set_accelerometer_sample_rate(rate = 125) {\n        /* Set the accelerometer sample rate in Hz. */\n        selectBank(2);\n        // 125Hz - 1.125 kHz / (1 + rate)\n        //rate = Number((1125.0 / rate) - 1);\n        rate = (1125.0 / rate) - 1;\n        // TODO maybe use struct to pack and then write_bytes\n        write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n        write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n    }\n    function set_accelerometer_full_scale(scale = 16) {\n        /* Set the accelerometer fulls cale range to +- the supplied value. */\n        selectBank(2);\n        let value = read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n        ///////value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n        write(ICM20948_ACCEL_CONFIG, value);\n    }\n    function set_accelerometer_low_pass(enabled = true, mode = 5) {\n        /* Configure the accelerometer low pass filter. */\n        selectBank(2);\n        let value = read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            write(ICM20948_ACCEL_CONFIG, value);\n        }\n    }\n    function set_gyro_sample_rate(rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        selectBank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = (1125.0 / rate) - 1;\n        write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n    function set_gyro_full_scale(scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        selectBank(2);\n        let value = read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        /////value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        write(ICM20948_GYRO_CONFIG_1, value);\n    }\n    function set_gyro_low_pass(enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        selectBank(2);\n        let value = read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n        }\n        value |= (mode & 0x07) << 4;\n        write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    function read_temperature() {\n        /* Property to read the current IMU temperature */\n        // PWR_MGMT_1 defaults to leave temperature enabled\n        selectBank(0);\n        let temp_raw_bytes = read_bytes(ICM20948_TEMP_OUT_H, 2);\n        let temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0];\n        let temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n        return temperature_deg_c;\n    }\n\n    function initLcm20948(i2c_addr = I2C_ADDR, i2c_bus = null) {\n        _bank = -1;\n        _addr = i2c_addr;\n        /*\n            if (i2c_bus === null) {\n                from smbus2 var SMBus = require('SMBus');\n                _bus = SMBus(1);\n            } else {\n                _bus = i2c_bus;\n            }\n        */\n    }\n    selectBank(0);\n    if (!read(ICM20948_WHO_AM_I) == CHIP_ID) {\n        throw RuntimeError('Unable to find ICM20948');\n    }\n    write(ICM20948_PWR_MGMT_1, 0x80);\n    basic.pause(10) //time.sleep(0.01);\n    write(ICM20948_PWR_MGMT_1, 0x01);\n    write(ICM20948_PWR_MGMT_2, 0x00);\n\n    selectBank(2);\n\n    set_gyro_sample_rate(100);\n    set_gyro_low_pass(enabled = true, mode = 5);\n    set_gyro_full_scale(250);\n\n    set_accelerometer_sample_rate(125);\n    set_accelerometer_low_pass(enabled = true, mode = 5);\n    set_accelerometer_full_scale(16);\n\n    selectBank(0);\n    write(ICM20948_INT_PIN_CFG, 0x30);\n\n    selectBank(3);\n    write(ICM20948_I2C_MST_CTRL, 0x4D);\n    write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n    if (!mag_read(AK09916_WIA) == AK09916_CHIP_ID) {\n        throw RuntimeError('Unable to find AK09916');\n    }\n    // Reset the magnetometer\n    mag_write(AK09916_CNTL3, 0x01);\n    while (mag_read(AK09916_CNTL3) == 0x01) {\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n\n}\n    /*\n    if (__name__ == '__main__') {\n        imu = ICM20948();\n    }\n        while (true) {\n            x, y, z = imu.read_magnetometer_data();\n            ax, ay, az, gx, gy, gz = imu.read_accelerometer_gyro_data();\n        }\n            Logger.log(x,y,z,ax,ay,az,gx,gy,gz)\n            /*\n    //Accel: {ax:05.2f} {ay:05.2f} {az:05.2f}\n    //Gyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\n    //Mag:   {x:05.2f} {y:05.2f} {z:05.2f} \n\n    basic.pause(250) //time.sleep(0.25)\n        */\n","pxt.json":"{\n    \"name\": \"test_i2c\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\",\n        \"pins_extra.ts\",\n        \"LCM20948.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1760631447495,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n\nconst CHIP_ID = 0xEA;\nconst I2C_ADDR = 0x68;\nconst I2C_ADDR_ALT = 0x69;\nconst ICM20948_BANK_SEL = 0x7f;\n\nconst ICM20948_I2C_MST_ODR_CONFIG = 0x00;\nconst ICM20948_I2C_MST_CTRL = 0x01;\nconst ICM20948_I2C_MST_DELAY_CTRL = 0x02;\nconst ICM20948_I2C_SLV0_ADDR = 0x03;\nconst ICM20948_I2C_SLV0_REG = 0x04;\nconst ICM20948_I2C_SLV0_CTRL = 0x05;\nconst ICM20948_I2C_SLV0_DO = 0x06;\nconst ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\nconst ICM20948_GYRO_SMPLRT_DIV = 0x00;\nconst ICM20948_GYRO_CONFIG_1 = 0x01;\nconst ICM20948_GYRO_CONFIG_2 = 0x02;\n\n// Bank 0\nconst ICM20948_WHO_AM_I = 0x00;\nconst ICM20948_USER_CTRL = 0x03;\nconst ICM20948_PWR_MGMT_1 = 0x06;\nconst ICM20948_PWR_MGMT_2 = 0x07;\nconst ICM20948_INT_PIN_CFG = 0x0F;\n\nconst ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\nconst ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\nconst ICM20948_ACCEL_INTEL_CTRL = 0x12;\nconst ICM20948_ACCEL_WOM_THR = 0x13;\nconst ICM20948_ACCEL_CONFIG = 0x14;\nconst ICM20948_ACCEL_XOUT_H = 0x2D;\nconst ICM20948_GRYO_XOUT_H = 0x33;\n\nconst ICM20948_TEMP_OUT_H = 0x39;\nconst ICM20948_TEMP_OUT_L = 0x3A;\n\n// Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nconst ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\nconst ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\nconst ICM20948_ROOM_TEMP_OFFSET = 21;\n\nconst AK09916_I2C_ADDR = 0x0c;\nconst AK09916_CHIP_ID = 0x09;\nconst AK09916_WIA = 0x01;\nconst AK09916_ST1 = 0x10;\nconst AK09916_ST1_DOR = 0b00000010   // Data overflow bit\nconst AK09916_ST1_DRDY = 0b00000001  // Data ready bit\nconst AK09916_HXL = 0x11;\nconst AK09916_ST2 = 0x18;\nconst AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\nconst AK09916_CNTL2 = 0x31;\nconst AK09916_CNTL2_MODE = 0b00001111;\nconst AK09916_CNTL2_MODE_OFF = 0;\nconst AK09916_CNTL2_MODE_SINGLE = 1;\nconst AK09916_CNTL2_MODE_CONT1 = 2;\nconst AK09916_CNTL2_MODE_CONT2 = 4;\nconst AK09916_CNTL2_MODE_CONT3 = 6;\nconst AK09916_CNTL2_MODE_CONT4 = 8;\nconst AK09916_CNTL2_MODE_TEST = 16;\nconst AK09916_CNTL3 = 0x32;\nlet twoBytes = pins.createBuffer(2)\npins.i2cWriteBuffer(I2C_ADDR,twoBytes,false)\n// try addressing the IMU\ndatalogger.mirrorToSerial(true)\ndatalogger.log(datalogger.createCV(\"startup\", 12345))\npins.i2cWriteNumber(I2C_ADDR, ICM20948_WHO_AM_I,NumberFormat.UInt8LE)\nlet me = pins.i2cReadNumber(I2C_ADDR,NumberFormat.UInt8LE,false)\ndatalogger.log(datalogger.createCV(\"me\", me))\n\npins.i2cWriteBuffer(I2C_ADDR,buffer,false)","README.md":"","main.py":"","pins_extra.ts":"/*\nfunction fetch_byte_reg(address: number, byte_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, byte_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Ubyte(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int8LE, false))\n}\ncontrol.waitMicros(4)\n*/\n\n/*\nfunction fetch_word_reg(word_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, word_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Uword(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int16BE, false))\n}\n*/\n/*\nfunction getreg(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt8BE);\n}\n*/\n\n/*\nfunction getInt8LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int8LE);\n}\n*/\n\n/*\nfunction getUInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt16LE);\n}\n*/\n\n/*\nfunction getInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int16LE);\n}\n*/","LCM20948.ts":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\nnamespace ICM {\n\n    const CHIP_ID = 0xEA;\n    const I2C_ADDR = 0x68;\n    const I2C_ADDR_ALT = 0x69;\n    const ICM20948_BANK_SEL = 0x7f;\n\n    const ICM20948_I2C_MST_ODR_CONFIG = 0x00;\n    const ICM20948_I2C_MST_CTRL = 0x01;\n    const ICM20948_I2C_MST_DELAY_CTRL = 0x02;\n    const ICM20948_I2C_SLV0_ADDR = 0x03;\n    const ICM20948_I2C_SLV0_REG = 0x04;\n    const ICM20948_I2C_SLV0_CTRL = 0x05;\n    const ICM20948_I2C_SLV0_DO = 0x06;\n    const ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\n    const ICM20948_GYRO_SMPLRT_DIV = 0x00;\n    const ICM20948_GYRO_CONFIG_1 = 0x01;\n    const ICM20948_GYRO_CONFIG_2 = 0x02;\n\n    // Bank 0\n    const ICM20948_WHO_AM_I = 0x00;\n    const ICM20948_USER_CTRL = 0x03;\n    const ICM20948_PWR_MGMT_1 = 0x06;\n    const ICM20948_PWR_MGMT_2 = 0x07;\n    const ICM20948_INT_PIN_CFG = 0x0F;\n\n    const ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\n    const ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\n    const ICM20948_ACCEL_INTEL_CTRL = 0x12;\n    const ICM20948_ACCEL_WOM_THR = 0x13;\n    const ICM20948_ACCEL_CONFIG = 0x14;\n    const ICM20948_ACCEL_XOUT_H = 0x2D;\n    const ICM20948_GRYO_XOUT_H = 0x33;\n\n    const ICM20948_TEMP_OUT_H = 0x39;\n    const ICM20948_TEMP_OUT_L = 0x3A;\n\n    // Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\n    const ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\n    const ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\n    const ICM20948_ROOM_TEMP_OFFSET = 21;\n\n    const AK09916_I2C_ADDR = 0x0c;\n    const AK09916_CHIP_ID = 0x09;\n    const AK09916_WIA = 0x01;\n    const AK09916_ST1 = 0x10;\n    const AK09916_ST1_DOR = 0b00000010   // Data overflow bit\n    const AK09916_ST1_DRDY = 0b00000001  // Data ready bit\n    const AK09916_HXL = 0x11;\n    const AK09916_ST2 = 0x18;\n    const AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\n    const AK09916_CNTL2 = 0x31;\n    const AK09916_CNTL2_MODE = 0b00001111;\n    const AK09916_CNTL2_MODE_OFF = 0;\n    const AK09916_CNTL2_MODE_SINGLE = 1;\n    const AK09916_CNTL2_MODE_CONT1 = 2;\n    const AK09916_CNTL2_MODE_CONT2 = 4;\n    const AK09916_CNTL2_MODE_CONT3 = 6;\n    const AK09916_CNTL2_MODE_CONT4 = 8;\n    const AK09916_CNTL2_MODE_TEST = 16;\n    const AK09916_CNTL3 = 0x32;\n\n    // GLOBALS\n    let registerBank = -1 // currently-selected register-bank\n    let imu \n\n\n    function write(reg:uint8, value:uint8) {\n        /* Write byte to the sensor. */\n        //_bus.write_byte_data(_addr, reg, value);\n\n        let twoBytes = pins.createBuffer(2)\n        twoBytes[0] = I2C_ADDR\n        twoBytes[1] = reg\n        pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n    function read(reg: uint8) {\n        /* Read byte from the sensor. */\n        // return _bus.read_byte_data(_addr, reg);\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        return pins.i2cReadNumber(I2C_ADDR, NumberFormat.UInt8LE, false)\n    }\n\n    function read_bytes(reg: uint8, length = 1) {\n        /* Read byte(s) from the sensor. */\n        // return _bus.read_i2c_block_data(_addr, reg, length);\n        let buf = pins.createBuffer(length)\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        buf = pins.i2cReadBuffer(I2C_ADDR, length, false)\n        return buf\n    }\n\n\n    function selectBank(value: uint8) {\n        /* Switch register bank. */\n        if (!(registerBank == value)) {\n            write(ICM20948_BANK_SEL, value << 4);\n            registerBank = value;\n        }\n    }\n    function trigger_mag_io() {\n        let user = read(ICM20948_USER_CTRL);\n        write(ICM20948_USER_CTRL, user | 0x20);\n        control.waitMicros(5000) //time.sleep(0.005);\n        write(ICM20948_USER_CTRL, user);\n    }\n\n\n    function mag_write(reg: uint8, value: uint8) {\n        /* Write a byte to the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, value);\n        selectBank(0);\n        trigger_mag_io();\n    }\n    function mag_read(reg: uint8) {\n        /* Read a byte from the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, 0xff);\n\n        selectBank(0);\n        trigger_mag_io();\n\n        return read(ICM20948_EXT_SLV_SENS_DATA_00);\n    }\n\n    function mag_read_bytes(reg: uint8, length = 1) {\n    /* Read up to 24 bytes from the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, 0xff);\n        selectBank(0);\n        trigger_mag_io();\n\n        return read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n    }\n\n    function magnetometer_ready() {\n        /* Check the magnetometer status ready bit. */\n        return (mag_read(AK09916_ST1) & 0x01) > 0;\n    }\n    function read_magnetometer_data(timeout = 1.0) {\n        mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n        let t_start = control.millis()\n        while (!magnetometer_ready()) {\n            if (control.millis() - t_start > timeout) {\n                /////throw RuntimeError('Timeout waiting for Magnetometer Ready');\n                control.waitMicros(10) //time.sleep(0.00001);\n            }\n            let data = mag_read_bytes(AK09916_HXL, 6);\n        }\n        // Read ST2 to confirm read finished,\n        // needed for continuous modes\n        // mag_read(AK09916_ST2)\n\n        //////x, y, z = struct.unpack('<hhh', bytearray(data));\n        let x = 0\n        let y = 0\n        let z = 0\n\n        // Scale for magnetic flux density \"uT\"\n        // from section 3.3 of the datasheet\n        // This value is constant\n        x *= 0.15;\n        y *= 0.15;\n        z *= 0.15;\n\n        return x, y, z;\n    }\n\n    function read_accelerometer_gyro_data() {\n        selectBank(0);\n        let data = read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n        //ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n        //dissect 12 bytes into 6 words\n        let ax = (data[0] << 8) + data[1]\n        let ay = (data[2] << 8) + data[3]\n        let az = (data[4] << 8) + data[5]\n        let gx = (data[6] << 8) + data[7]\n        let gy = (data[8] << 8) + data[9]\n        let gz = (data[10] << 8) + data[11]\n\n        selectBank(2);\n\n        // Read accelerometer full scale range and\n        // use it to compensate the reading to gs\n        let scale = (read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n        // scale ranges from section 3.2 of the datasheet\n        let gs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\n        ax /= gs;\n        ay /= gs;\n        az /= gs;\n\n        // Read back the degrees per second rate and\n        // use it to compensate the reading to dps\n        scale = (read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n        // scale ranges from section 3.1 of the datasheet\n        dps = [131, 65.5, 32.8, 16.4][scale];\n\n        gx /= dps;\n        gy /= dps;\n        gz /= dps;\n\n        return ax, ay, az, gx, gy, gz;\n    }\n\n    function set_accelerometer_sample_rate(rate = 125) {\n        /* Set the accelerometer sample rate in Hz. */\n        selectBank(2);\n        // 125Hz - 1.125 kHz / (1 + rate)\n        //rate = Number((1125.0 / rate) - 1);\n        rate = (1125.0 / rate) - 1;\n        // TODO maybe use struct to pack and then write_bytes\n        write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n        write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n    }\n    function set_accelerometer_full_scale(scale = 16) {\n        /* Set the accelerometer fulls cale range to +- the supplied value. */\n        selectBank(2);\n        let value = read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n        ///////value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n        write(ICM20948_ACCEL_CONFIG, value);\n    }\n    function set_accelerometer_low_pass(enabled = true, mode = 5) {\n        /* Configure the accelerometer low pass filter. */\n        selectBank(2);\n        let value = read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            write(ICM20948_ACCEL_CONFIG, value);\n        }\n    }\n    function set_gyro_sample_rate(rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        selectBank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = (1125.0 / rate) - 1;\n        write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n    function set_gyro_full_scale(scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        selectBank(2);\n        let value = read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        /////value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        write(ICM20948_GYRO_CONFIG_1, value);\n    }\n    function set_gyro_low_pass(enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        selectBank(2);\n        let value = read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n        }\n        value |= (mode & 0x07) << 4;\n        write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    function read_temperature() {\n        /* Property to read the current IMU temperature */\n        // PWR_MGMT_1 defaults to leave temperature enabled\n        selectBank(0);\n        let temp_raw_bytes = read_bytes(ICM20948_TEMP_OUT_H, 2);\n        let temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0];\n        let temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n        return temperature_deg_c;\n    }\n\n    function initLcm20948(i2c_addr = I2C_ADDR, i2c_bus = null) {\n        registerBank = -1;\n        _addr = i2c_addr;\n        /*\n            if (i2c_bus === null) {\n                from smbus2 var SMBus = require('SMBus');\n                _bus = SMBus(1);\n            } else {\n                _bus = i2c_bus;\n            }\n        */\n    }\n    selectBank(0);\n    if (!read(ICM20948_WHO_AM_I) == CHIP_ID) {\n        throw RuntimeError('Unable to find ICM20948');\n    }\n    write(ICM20948_PWR_MGMT_1, 0x80);\n    basic.pause(10) //time.sleep(0.01);\n    write(ICM20948_PWR_MGMT_1, 0x01);\n    write(ICM20948_PWR_MGMT_2, 0x00);\n\n    selectBank(2);\n\n    set_gyro_sample_rate(100);\n    set_gyro_low_pass(enabled = true, mode = 5);\n    set_gyro_full_scale(250);\n\n    set_accelerometer_sample_rate(125);\n    set_accelerometer_low_pass(enabled = true, mode = 5);\n    set_accelerometer_full_scale(16);\n\n    selectBank(0);\n    write(ICM20948_INT_PIN_CFG, 0x30);\n\n    selectBank(3);\n    write(ICM20948_I2C_MST_CTRL, 0x4D);\n    write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n    if (!mag_read(AK09916_WIA) == AK09916_CHIP_ID) {\n        throw RuntimeError('Unable to find AK09916');\n    }\n    // Reset the magnetometer\n    mag_write(AK09916_CNTL3, 0x01);\n    while (mag_read(AK09916_CNTL3) == 0x01) {\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n\n}\n    /*\n    if (__name__ == '__main__') {\n        imu = ICM20948();\n    }\n        while (true) {\n            x, y, z = imu.read_magnetometer_data();\n            ax, ay, az, gx, gy, gz = imu.read_accelerometer_gyro_data();\n        }\n            Logger.log(x,y,z,ax,ay,az,gx,gy,gz)\n            /*\n    //Accel: {ax:05.2f} {ay:05.2f} {az:05.2f}\n    //Gyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\n    //Mag:   {x:05.2f} {y:05.2f} {z:05.2f} \n\n    basic.pause(250) //time.sleep(0.25)\n        */\n","pxt.json":"{\n    \"name\": \"test_i2c\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\",\n        \"pins_extra.ts\",\n        \"LCM20948.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1760633250807,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n\nconst CHIP_ID = 0xEA;\nconst I2C_ADDR = 0x68;\nconst I2C_ADDR_ALT = 0x69;\nconst ICM20948_BANK_SEL = 0x7f;\n\nconst ICM20948_I2C_MST_ODR_CONFIG = 0x00;\nconst ICM20948_I2C_MST_CTRL = 0x01;\nconst ICM20948_I2C_MST_DELAY_CTRL = 0x02;\nconst ICM20948_I2C_SLV0_ADDR = 0x03;\nconst ICM20948_I2C_SLV0_REG = 0x04;\nconst ICM20948_I2C_SLV0_CTRL = 0x05;\nconst ICM20948_I2C_SLV0_DO = 0x06;\nconst ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\nconst ICM20948_GYRO_SMPLRT_DIV = 0x00;\nconst ICM20948_GYRO_CONFIG_1 = 0x01;\nconst ICM20948_GYRO_CONFIG_2 = 0x02;\n\n// Bank 0\nconst ICM20948_WHO_AM_I = 0x00;\nconst ICM20948_USER_CTRL = 0x03;\nconst ICM20948_PWR_MGMT_1 = 0x06;\nconst ICM20948_PWR_MGMT_2 = 0x07;\nconst ICM20948_INT_PIN_CFG = 0x0F;\n\nconst ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\nconst ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\nconst ICM20948_ACCEL_INTEL_CTRL = 0x12;\nconst ICM20948_ACCEL_WOM_THR = 0x13;\nconst ICM20948_ACCEL_CONFIG = 0x14;\nconst ICM20948_ACCEL_XOUT_H = 0x2D;\nconst ICM20948_GRYO_XOUT_H = 0x33;\n\nconst ICM20948_TEMP_OUT_H = 0x39;\nconst ICM20948_TEMP_OUT_L = 0x3A;\n\n// Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nconst ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\nconst ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\nconst ICM20948_ROOM_TEMP_OFFSET = 21;\n\nconst AK09916_I2C_ADDR = 0x0c;\nconst AK09916_CHIP_ID = 0x09;\nconst AK09916_WIA = 0x01;\nconst AK09916_ST1 = 0x10;\nconst AK09916_ST1_DOR = 0b00000010   // Data overflow bit\nconst AK09916_ST1_DRDY = 0b00000001  // Data ready bit\nconst AK09916_HXL = 0x11;\nconst AK09916_ST2 = 0x18;\nconst AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\nconst AK09916_CNTL2 = 0x31;\nconst AK09916_CNTL2_MODE = 0b00001111;\nconst AK09916_CNTL2_MODE_OFF = 0;\nconst AK09916_CNTL2_MODE_SINGLE = 1;\nconst AK09916_CNTL2_MODE_CONT1 = 2;\nconst AK09916_CNTL2_MODE_CONT2 = 4;\nconst AK09916_CNTL2_MODE_CONT3 = 6;\nconst AK09916_CNTL2_MODE_CONT4 = 8;\nconst AK09916_CNTL2_MODE_TEST = 16;\nconst AK09916_CNTL3 = 0x32;\n\n/*\nlet twoBytes = pins.createBuffer(2)\npins.i2cWriteBuffer(I2C_ADDR,twoBytes,false)\n\n// try addressing the IMU\ndatalogger.mirrorToSerial(true)\ndatalogger.log(datalogger.createCV(\"startup\", 12345))\npins.i2cWriteNumber(I2C_ADDR, ICM20948_WHO_AM_I,NumberFormat.UInt8LE)\nlet me = pins.i2cReadNumber(I2C_ADDR,NumberFormat.UInt8LE,false)\ndatalogger.log(datalogger.createCV(\"me\", me))\n\npins.i2cWriteBuffer(I2C_ADDR,buffer,false)\n*/\nlet imu = new(ICM())\n\nlet mag = []\nlet gyro = []\nwhile (true) {\n    mag = imu.read_magnetometer_data();\n    gyro = imu.read_accelerometer_gyro_data();\n\n    Logger.log(\n        datalogger.createCV(\"Mag_X\", mag[0]),\n        datalogger.createCV(\"Mag_Y\", mag[1]),\n        datalogger.createCV(\"Mag_Z\", mag[2]),\n        datalogger.createCV(\"Accel_X\", gyro[0]),\n        datalogger.createCV(\"Accel_Y\", gyro[1]),\n        datalogger.createCV(\"Accel_Z\", gyro[2]),\n        datalogger.createCV(\"Spin_X\", gyro[3]),\n        datalogger.createCV(\"Spin_X\", gyro[4]),\n        datalogger.createCV(\"Spin_X\", gyro[5])\n    )\n}\n    /*\n//Accel: {ax:05.2f} {ay:05.2f} {az:05.2f}\n//Gyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\n//Mag:   {x:05.2f} {y:05.2f} {z:05.2f}\n\nbasic.pause(250) //time.sleep(0.25)\n*/\n","README.md":"","main.py":"","pins_extra.ts":"/*\nfunction fetch_byte_reg(address: number, byte_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, byte_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Ubyte(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int8LE, false))\n}\ncontrol.waitMicros(4)\n*/\n\n/*\nfunction fetch_word_reg(word_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, word_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Uword(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int16BE, false))\n}\n*/\n/*\nfunction getreg(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt8BE);\n}\n*/\n\n/*\nfunction getInt8LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int8LE);\n}\n*/\n\n/*\nfunction getUInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt16LE);\n}\n*/\n\n/*\nfunction getInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int16LE);\n}\n*/","LCM20948.ts":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\nnamespace ICM {\n    const CHIP_ID = 0xEA;\n    const I2C_ADDR = 0x68;\n    const I2C_ADDR_ALT = 0x69;\n    const ICM20948_BANK_SEL = 0x7f;\n\n    const ICM20948_NOT_FOUND = 222; // Panic code!\n\n\n    const ICM20948_I2C_MST_ODR_CONFIG = 0x00;\n    const ICM20948_I2C_MST_CTRL = 0x01;\n    const ICM20948_I2C_MST_DELAY_CTRL = 0x02;\n    const ICM20948_I2C_SLV0_ADDR = 0x03;\n    const ICM20948_I2C_SLV0_REG = 0x04;\n    const ICM20948_I2C_SLV0_CTRL = 0x05;\n    const ICM20948_I2C_SLV0_DO = 0x06;\n    const ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\n    const ICM20948_GYRO_SMPLRT_DIV = 0x00;\n    const ICM20948_GYRO_CONFIG_1 = 0x01;\n    const ICM20948_GYRO_CONFIG_2 = 0x02;\n\n    // Bank 0\n    const ICM20948_WHO_AM_I = 0x00;\n    const ICM20948_USER_CTRL = 0x03;\n    const ICM20948_PWR_MGMT_1 = 0x06;\n    const ICM20948_PWR_MGMT_2 = 0x07;\n    const ICM20948_INT_PIN_CFG = 0x0F;\n\n    const ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\n    const ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\n    const ICM20948_ACCEL_INTEL_CTRL = 0x12;\n    const ICM20948_ACCEL_WOM_THR = 0x13;\n    const ICM20948_ACCEL_CONFIG = 0x14;\n    const ICM20948_ACCEL_XOUT_H = 0x2D;\n    const ICM20948_GRYO_XOUT_H = 0x33;\n\n    const ICM20948_TEMP_OUT_H = 0x39;\n    const ICM20948_TEMP_OUT_L = 0x3A;\n\n    // Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\n    const ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\n    const ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\n    const ICM20948_ROOM_TEMP_OFFSET = 21;\n\n    const AK09916_I2C_ADDR = 0x0c;\n    const AK09916_CHIP_ID = 0x09;\n    const AK09916_WIA = 0x01;\n    const AK09916_NOT_FOUND = 222; // Panic code!\n\n    const AK09916_ST1 = 0x10;\n    const AK09916_ST1_DOR = 0b00000010   // Data overflow bit\n    const AK09916_ST1_DRDY = 0b00000001  // Data ready bit\n    const AK09916_HXL = 0x11;\n    const AK09916_ST2 = 0x18;\n    const AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\n    const AK09916_CNTL2 = 0x31;\n    const AK09916_CNTL2_MODE = 0b00001111;\n    const AK09916_CNTL2_MODE_OFF = 0;\n    const AK09916_CNTL2_MODE_SINGLE = 1;\n    const AK09916_CNTL2_MODE_CONT1 = 2;\n    const AK09916_CNTL2_MODE_CONT2 = 4;\n    const AK09916_CNTL2_MODE_CONT3 = 6;\n    const AK09916_CNTL2_MODE_CONT4 = 8;\n    const AK09916_CNTL2_MODE_TEST = 16;\n    const AK09916_CNTL3 = 0x32;\n\n    class ICM20948 {\n    // GLOBALS\n    let registerBank = -1 // currently-selected register-bank\n    let imuAddress = 0 // I2C master address of ICM20948\n\n\n    function write(reg:uint8, value:uint8) {\n        /* Write byte to the sensor. */\n        //_bus.write_byte_data(_addr, reg, value);\n\n        let twoBytes = pins.createBuffer(2)\n        twoBytes[0] = I2C_ADDR\n        twoBytes[1] = reg\n        pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n    function read(reg: uint8) {\n        /* Read byte from the sensor. */\n        // return _bus.read_byte_data(_addr, reg);\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        return pins.i2cReadNumber(I2C_ADDR, NumberFormat.UInt8LE, false)\n    }\n\n    function read_bytes(reg: uint8, length = 1) {\n        /* Read byte(s) from the sensor. */\n        // return _bus.read_i2c_block_data(_addr, reg, length);\n        let buf = pins.createBuffer(length)\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        buf = pins.i2cReadBuffer(I2C_ADDR, length, false)\n        return buf\n    }\n\n\n    function selectBank(value: uint8) {\n        /* Switch register bank. */\n        if (!(registerBank == value)) {\n            write(ICM20948_BANK_SEL, value << 4);\n            registerBank = value;\n        }\n    }\n    function trigger_mag_io() {\n        let user = read(ICM20948_USER_CTRL);\n        write(ICM20948_USER_CTRL, user | 0x20);\n        control.waitMicros(5000) //time.sleep(0.005);\n        write(ICM20948_USER_CTRL, user);\n    }\n\n\n    function mag_write(reg: uint8, value: uint8) {\n        /* Write a byte to the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, value);\n        selectBank(0);\n        trigger_mag_io();\n    }\n    function mag_read(reg: uint8) {\n        /* Read a byte from the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, 0xff);\n\n        selectBank(0);\n        trigger_mag_io();\n\n        return read(ICM20948_EXT_SLV_SENS_DATA_00);\n    }\n\n    function mag_read_bytes(reg: uint8, length = 1) {\n    /* Read up to 24 bytes from the slave magnetometer. */\n        selectBank(3);\n        write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n        write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        write(ICM20948_I2C_SLV0_REG, reg);\n        write(ICM20948_I2C_SLV0_DO, 0xff);\n        selectBank(0);\n        trigger_mag_io();\n\n        return read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n    }\n\n    function magnetometer_ready() {\n        /* Check the magnetometer status ready bit. */\n        return (mag_read(AK09916_ST1) & 0x01) > 0;\n    }\n    function read_magnetometer_data(timeout = 1.0) {\n        mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n        let t_start = control.millis()\n        while (!magnetometer_ready()) {\n            if (control.millis() - t_start > timeout) {\n                /////throw RuntimeError('Timeout waiting for Magnetometer Ready');\n                control.waitMicros(10) //time.sleep(0.00001);\n            }\n            let data = mag_read_bytes(AK09916_HXL, 6);\n        }\n        // Read ST2 to confirm read finished,\n        // needed for continuous modes\n        // mag_read(AK09916_ST2)\n\n        //////x, y, z = struct.unpack('<hhh', bytearray(data));\n        let x = 0\n        let y = 0\n        let z = 0\n\n        // Scale for magnetic flux density \"uT\"\n        // from section 3.3 of the datasheet\n        // This value is constant\n        x *= 0.15;\n        y *= 0.15;\n        z *= 0.15;\n\n        return x, y, z;\n    }\n\n    function read_accelerometer_gyro_data() {\n        selectBank(0);\n        let data = read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n        //ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n        //dissect 12 bytes into 6 words\n        let ax = (data[0] << 8) + data[1]\n        let ay = (data[2] << 8) + data[3]\n        let az = (data[4] << 8) + data[5]\n        let gx = (data[6] << 8) + data[7]\n        let gy = (data[8] << 8) + data[9]\n        let gz = (data[10] << 8) + data[11]\n\n        selectBank(2);\n\n        // Read accelerometer full scale range and\n        // use it to compensate the reading to gs\n        let scale = (read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n        // scale ranges from section 3.2 of the datasheet\n        let gs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\n        ax /= gs;\n        ay /= gs;\n        az /= gs;\n\n        // Read back the degrees per second rate and\n        // use it to compensate the reading to dps\n        scale = (read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n        // scale ranges from section 3.1 of the datasheet\n        let dps = [131, 65.5, 32.8, 16.4][scale];\n\n        gx /= dps;\n        gy /= dps;\n        gz /= dps;\n\n        return ax, ay, az, gx, gy, gz;\n    }\n\n    function set_accelerometer_sample_rate(rate = 125) {\n        /* Set the accelerometer sample rate in Hz. */\n        selectBank(2);\n        // 125Hz - 1.125 kHz / (1 + rate)\n        //rate = Number((1125.0 / rate) - 1);\n        rate = (1125.0 / rate) - 1;\n        // TODO maybe use struct to pack and then write_bytes\n        write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n        write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n    }\n    function set_accelerometer_full_scale(scale = 16) {\n        /* Set the accelerometer fulls cale range to +- the supplied value. */\n        selectBank(2);\n        let value = read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n        ///////value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n        write(ICM20948_ACCEL_CONFIG, value);\n    }\n    function set_accelerometer_low_pass(enabled = true, mode = 5) {\n        /* Configure the accelerometer low pass filter. */\n        selectBank(2);\n        let value = read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            write(ICM20948_ACCEL_CONFIG, value);\n        }\n    }\n    function set_gyro_sample_rate(rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        selectBank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = (1125.0 / rate) - 1;\n        write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n    function set_gyro_full_scale(scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        selectBank(2);\n        let value = read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        /////value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        write(ICM20948_GYRO_CONFIG_1, value);\n    }\n    function set_gyro_low_pass(enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        selectBank(2);\n        let value = read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n        }\n        value |= (mode & 0x07) << 4;\n        write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    function read_temperature() {\n        /* Property to read the current IMU temperature */\n        // PWR_MGMT_1 defaults to leave temperature enabled\n        selectBank(0);\n        let temp_raw_bytes = read_bytes(ICM20948_TEMP_OUT_H, 2);\n        //let temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0];\n        let temp_raw = (temp_raw_bytes[0] << 8) + temp_raw_bytes[1]\n        let temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n        return temperature_deg_c;\n    }\n\n    function initLcm20948(i2c_addr = I2C_ADDR) {\n        registerBank = -1;\n        imuAddress = i2c_addr;\n        /*\n            if (i2c_bus === null) {\n                from smbus2 var SMBus = require('SMBus');\n                _bus = SMBus(1);\n            } else {\n                _bus = i2c_bus;\n            }\n        */\n    }\n    selectBank(0);\n    if (read(ICM20948_WHO_AM_I) != CHIP_ID) {\n        //throw RuntimeError('Unable to find ICM20948');\n        control.panic(ICM20948_NOT_FOUND)\n    }\n    write(ICM20948_PWR_MGMT_1, 0x80);\n    basic.pause(10) //time.sleep(0.01);\n    write(ICM20948_PWR_MGMT_1, 0x01);\n    write(ICM20948_PWR_MGMT_2, 0x00);\n\n    selectBank(2);\n\n    set_gyro_sample_rate(100);\n    set_gyro_low_pass(true, 5);\n    set_gyro_full_scale(250);\n\n    set_accelerometer_sample_rate(125);\n    set_accelerometer_low_pass(true, 5);\n    set_accelerometer_full_scale(16);\n\n    selectBank(0);\n    write(ICM20948_INT_PIN_CFG, 0x30);\n\n    selectBank(3);\n    write(ICM20948_I2C_MST_CTRL, 0x4D);\n    write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n    if (mag_read(AK09916_WIA) != AK09916_CHIP_ID) {\n        // throw RuntimeError('Unable to find AK09916');\n        control.panic(AK09916_NOT_FOUND)\n    }\n    // Reset the magnetometer\n    mag_write(AK09916_CNTL3, 0x01);\n    while (mag_read(AK09916_CNTL3) == 0x01) {\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n    }\n}\n    /*\n    if (__name__ == '__main__') {\n        imu = ICM20948();\n    }\n        while (true) {\n            x, y, z = imu.read_magnetometer_data();\n            ax, ay, az, gx, gy, gz = imu.read_accelerometer_gyro_data();\n        }\n            Logger.log(x,y,z,ax,ay,az,gx,gy,gz)\n            /*\n    //Accel: {ax:05.2f} {ay:05.2f} {az:05.2f}\n    //Gyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\n    //Mag:   {x:05.2f} {y:05.2f} {z:05.2f} \n\n    basic.pause(250) //time.sleep(0.25)\n        */\n","pxt.json":"{\n    \"name\": \"test_i2c\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\",\n        \"pins_extra.ts\",\n        \"LCM20948.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1760687542148,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n\nconst CHIP_ID = 0xEA;\nconst I2C_ADDR = 0x68;\nconst I2C_ADDR_ALT = 0x69;\nconst ICM20948_BANK_SEL = 0x7f;\n\nconst ICM20948_I2C_MST_ODR_CONFIG = 0x00;\nconst ICM20948_I2C_MST_CTRL = 0x01;\nconst ICM20948_I2C_MST_DELAY_CTRL = 0x02;\nconst ICM20948_I2C_SLV0_ADDR = 0x03;\nconst ICM20948_I2C_SLV0_REG = 0x04;\nconst ICM20948_I2C_SLV0_CTRL = 0x05;\nconst ICM20948_I2C_SLV0_DO = 0x06;\nconst ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\nconst ICM20948_GYRO_SMPLRT_DIV = 0x00;\nconst ICM20948_GYRO_CONFIG_1 = 0x01;\nconst ICM20948_GYRO_CONFIG_2 = 0x02;\n\n// Bank 0\nconst ICM20948_WHO_AM_I = 0x00;\nconst ICM20948_USER_CTRL = 0x03;\nconst ICM20948_PWR_MGMT_1 = 0x06;\nconst ICM20948_PWR_MGMT_2 = 0x07;\nconst ICM20948_INT_PIN_CFG = 0x0F;\n\nconst ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\nconst ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\nconst ICM20948_ACCEL_INTEL_CTRL = 0x12;\nconst ICM20948_ACCEL_WOM_THR = 0x13;\nconst ICM20948_ACCEL_CONFIG = 0x14;\nconst ICM20948_ACCEL_XOUT_H = 0x2D;\nconst ICM20948_GRYO_XOUT_H = 0x33;\n\nconst ICM20948_TEMP_OUT_H = 0x39;\nconst ICM20948_TEMP_OUT_L = 0x3A;\n\n// Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nconst ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\nconst ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\nconst ICM20948_ROOM_TEMP_OFFSET = 21;\n\nconst AK09916_I2C_ADDR = 0x0c;\nconst AK09916_CHIP_ID = 0x09;\nconst AK09916_WIA = 0x01;\nconst AK09916_ST1 = 0x10;\nconst AK09916_ST1_DOR = 0b00000010   // Data overflow bit\nconst AK09916_ST1_DRDY = 0b00000001  // Data ready bit\nconst AK09916_HXL = 0x11;\nconst AK09916_ST2 = 0x18;\nconst AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\nconst AK09916_CNTL2 = 0x31;\nconst AK09916_CNTL2_MODE = 0b00001111;\nconst AK09916_CNTL2_MODE_OFF = 0;\nconst AK09916_CNTL2_MODE_SINGLE = 1;\nconst AK09916_CNTL2_MODE_CONT1 = 2;\nconst AK09916_CNTL2_MODE_CONT2 = 4;\nconst AK09916_CNTL2_MODE_CONT3 = 6;\nconst AK09916_CNTL2_MODE_CONT4 = 8;\nconst AK09916_CNTL2_MODE_TEST = 16;\nconst AK09916_CNTL3 = 0x32;\n\n/*\nlet twoBytes = pins.createBuffer(2)\npins.i2cWriteBuffer(I2C_ADDR,twoBytes,false)\n\n// try addressing the IMU\ndatalogger.mirrorToSerial(true)\ndatalogger.log(datalogger.createCV(\"startup\", 12345))\npins.i2cWriteNumber(I2C_ADDR, ICM20948_WHO_AM_I,NumberFormat.UInt8LE)\nlet me = pins.i2cReadNumber(I2C_ADDR,NumberFormat.UInt8LE,false)\ndatalogger.log(datalogger.createCV(\"me\", me))\n\npins.i2cWriteBuffer(I2C_ADDR,buffer,false)\n*/\nlet imu = new(ICM())\n\nlet mag = []\nlet gyro = []\nwhile (true) {\n    mag = imu.read_magnetometer_data();\n    gyro = imu.read_accelerometer_gyro_data();\n\n    Logger.log(\n        datalogger.createCV(\"Mag_X\", mag[0]),\n        datalogger.createCV(\"Mag_Y\", mag[1]),\n        datalogger.createCV(\"Mag_Z\", mag[2]),\n        datalogger.createCV(\"Accel_X\", gyro[0]),\n        datalogger.createCV(\"Accel_Y\", gyro[1]),\n        datalogger.createCV(\"Accel_Z\", gyro[2]),\n        datalogger.createCV(\"Spin_X\", gyro[3]),\n        datalogger.createCV(\"Spin_X\", gyro[4]),\n        datalogger.createCV(\"Spin_X\", gyro[5])\n    )\n}\n    /*\n//Accel: {ax:05.2f} {ay:05.2f} {az:05.2f}\n//Gyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\n//Mag:   {x:05.2f} {y:05.2f} {z:05.2f}\n\nbasic.pause(250) //time.sleep(0.25)\n*/\n","README.md":"","main.py":"","pins_extra.ts":"/*\nfunction fetch_byte_reg(address: number, byte_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, byte_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Ubyte(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int8LE, false))\n}\ncontrol.waitMicros(4)\n*/\n\n/*\nfunction fetch_word_reg(word_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, word_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Uword(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int16BE, false))\n}\n*/\n/*\nfunction getreg(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt8BE);\n}\n*/\n\n/*\nfunction getInt8LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int8LE);\n}\n*/\n\n/*\nfunction getUInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt16LE);\n}\n*/\n\n/*\nfunction getInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int16LE);\n}\n*/","LCM20948.ts":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\nnamespace ICM {\n    const CHIP_ID = 0xEA;\n    const I2C_ADDR = 0x68;\n    const I2C_ADDR_ALT = 0x69;\n    const ICM20948_BANK_SEL = 0x7f;\n\n    const ICM20948_NOT_FOUND = 222; // Panic code!\n\n\n    const ICM20948_I2C_MST_ODR_CONFIG = 0x00;\n    const ICM20948_I2C_MST_CTRL = 0x01;\n    const ICM20948_I2C_MST_DELAY_CTRL = 0x02;\n    const ICM20948_I2C_SLV0_ADDR = 0x03;\n    const ICM20948_I2C_SLV0_REG = 0x04;\n    const ICM20948_I2C_SLV0_CTRL = 0x05;\n    const ICM20948_I2C_SLV0_DO = 0x06;\n    const ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\n    const ICM20948_GYRO_SMPLRT_DIV = 0x00;\n    const ICM20948_GYRO_CONFIG_1 = 0x01;\n    const ICM20948_GYRO_CONFIG_2 = 0x02;\n\n    // Bank 0\n    const ICM20948_WHO_AM_I = 0x00;\n    const ICM20948_USER_CTRL = 0x03;\n    const ICM20948_PWR_MGMT_1 = 0x06;\n    const ICM20948_PWR_MGMT_2 = 0x07;\n    const ICM20948_INT_PIN_CFG = 0x0F;\n\n    const ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\n    const ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\n    const ICM20948_ACCEL_INTEL_CTRL = 0x12;\n    const ICM20948_ACCEL_WOM_THR = 0x13;\n    const ICM20948_ACCEL_CONFIG = 0x14;\n    const ICM20948_ACCEL_XOUT_H = 0x2D;\n    const ICM20948_GRYO_XOUT_H = 0x33;\n\n    const ICM20948_TEMP_OUT_H = 0x39;\n    const ICM20948_TEMP_OUT_L = 0x3A;\n\n    // Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\n    const ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\n    const ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\n    const ICM20948_ROOM_TEMP_OFFSET = 21;\n\n    const AK09916_I2C_ADDR = 0x0c;\n    const AK09916_CHIP_ID = 0x09;\n    const AK09916_WIA = 0x01;\n    const AK09916_NOT_FOUND = 222; // Panic code!\n\n    const AK09916_ST1 = 0x10;\n    const AK09916_ST1_DOR = 0b00000010   // Data overflow bit\n    const AK09916_ST1_DRDY = 0b00000001  // Data ready bit\n    const AK09916_HXL = 0x11;\n    const AK09916_ST2 = 0x18;\n    const AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\n    const AK09916_CNTL2 = 0x31;\n    const AK09916_CNTL2_MODE = 0b00001111;\n    const AK09916_CNTL2_MODE_OFF = 0;\n    const AK09916_CNTL2_MODE_SINGLE = 1;\n    const AK09916_CNTL2_MODE_CONT1 = 2;\n    const AK09916_CNTL2_MODE_CONT2 = 4;\n    const AK09916_CNTL2_MODE_CONT3 = 6;\n    const AK09916_CNTL2_MODE_CONT4 = 8;\n    const AK09916_CNTL2_MODE_TEST = 16;\n    const AK09916_CNTL3 = 0x32;\n    // GLOBALS\n\n    class ICM20948 {\n        registerBank: number\n        imuAddress: number\n\n        constructor(myAddress:number) {\n            this.registerBank = -1; // currently-selected register-bank\n            this.imuAddress = myAddress; // I2C master address of ICM20948\n\n            this.selectBank(0);\n            if (this.read(ICM20948_WHO_AM_I) != CHIP_ID) {\n                //throw RuntimeError('Unable to find ICM20948');\n                control.panic(ICM20948_NOT_FOUND)\n            }\n            this.this.write(ICM20948_PWR_MGMT_1, 0x80);\n            basic.pause(10) //time.sleep(0.01);\n            this.this.write(ICM20948_PWR_MGMT_1, 0x01);\n            this.this.write(ICM20948_PWR_MGMT_2, 0x00);\n\n            this.selectBank(2);\n\n            this.set_gyro_sample_rate(100);\n            this.set_gyro_low_pass(true, 5);\n            this.set_gyro_full_scale(250);\n\n            this.set_accelerometer_sample_rate(125);\n            this.set_accelerometer_low_pass(true, 5);\n            this.set_accelerometer_full_scale(16);\n\n            this.selectBank(0);\n            this.this.write(ICM20948_INT_PIN_CFG, 0x30);\n\n            this.selectBank(3);\n            this.this.write(ICM20948_I2C_MST_CTRL, 0x4D);\n            this.this.write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n            if (this.mag_read(AK09916_WIA) != AK09916_CHIP_ID) {\n                // throw RuntimeError('Unable to find AK09916');\n                control.panic(AK09916_NOT_FOUND)\n            }\n            // Reset the magnetometer\n            this.mag_this.write(AK09916_CNTL3, 0x01);\n            while (this.mag_read(AK09916_CNTL3) == 0x01) {\n                control.waitMicros(100) //time.sleep(0.0001);\n            }\n        }\n\n        write(reg: uint8, value: uint8) {\n        /* Write byte to the sensor. */\n        //_bus.this.write_byte_data(_addr, reg, value);\n\n        let twoBytes = pins.createBuffer(2)\n        twoBytes[0] = I2C_ADDR\n        twoBytes[1] = reg\n        pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n\n    read(reg: uint8) {\n        /* Read byte from the sensor. */\n        // return _bus.read_byte_data(_addr, reg);\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        return pins.i2cReadNumber(I2C_ADDR, NumberFormat.UInt8LE, false)\n    }\n\n    read_bytes(reg: uint8, length = 1) {\n        /* Read byte(s) from the sensor. */\n        // return _bus.read_i2c_block_data(_addr, reg, length);\n        let buf = pins.createBuffer(length)\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        buf = pins.i2cReadBuffer(I2C_ADDR, length, false)\n        return buf\n    }\n\n\n    selectBank(value: uint8) {\n        /* Switch register bank. */\n        if (!(this.registerBank == value)) {\n            this.this.write(ICM20948_BANK_SEL, value << 4);\n            this.registerBank = value;\n        }\n    }\n    trigger_mag_io() {\n        let user = this.read(ICM20948_USER_CTRL);\n        this.write(ICM20948_USER_CTRL, user | 0x20);\n        control.waitMicros(5000) //time.sleep(0.005);\n        this.write(ICM20948_USER_CTRL, user);\n    }\n\n\n    mag_this.write(reg: uint8, value: uint8) {\n        /* Write a byte to the slave magnetometer. */\n        selectBank(3);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, value);\n        selectBank(0);\n        trigger_mag_io();\n    }\n\n    mag_read(reg: uint8) {\n        /* Read a byte from the slave magnetometer. */\n        selectBank(3);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, 0xff);\n\n        selectBank(0);\n        trigger_mag_io();\n\n        return read(ICM20948_EXT_SLV_SENS_DATA_00);\n    }\n\n\n    mag_read_bytes(reg: uint8, length = 1) {\n        /* Read up to 24 bytes from the slave magnetometer. */\n        selectBank(3);\n        this.write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, 0xff);\n        selectBank(0);\n        trigger_mag_io();\n\n        return read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n    }\n\n\n    magnetometer_ready() {\n        /* Check the magnetometer status ready bit. */\n        return (mag_read(AK09916_ST1) & 0x01) > 0;\n    }\n\n    read_magnetometer_data(timeout = 1.0) {\n        mag_this.write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n        let t_start = control.millis()\n        while (!magnetometer_ready()) {\n            if (control.millis() - t_start > timeout) {\n                /////throw RuntimeError('Timeout waiting for Magnetometer Ready');\n                control.waitMicros(10) //time.sleep(0.00001);\n            }\n            let data = mag_read_bytes(AK09916_HXL, 6);\n        }\n        // Read ST2 to confirm read finished,\n        // needed for continuous modes\n        // mag_read(AK09916_ST2)\n\n        //////x, y, z = struct.unpack('<hhh', bytearray(data));\n        let x = 0\n        let y = 0\n        let z = 0\n\n        // Scale for magnetic flux density \"uT\"\n        // from section 3.3 of the datasheet\n        // This value is constant\n        x *= 0.15;\n        y *= 0.15;\n        z *= 0.15;\n\n        return x, y, z;\n    }\n    read_accelerometer_gyro_data() {\n        selectBank(0);\n        let data = this.read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n        //ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n        //dissect 12 bytes into 6 words\n        let ax = (data[0] << 8) + data[1]\n        let ay = (data[2] << 8) + data[3]\n        let az = (data[4] << 8) + data[5]\n        let gx = (data[6] << 8) + data[7]\n        let gy = (data[8] << 8) + data[9]\n        let gz = (data[10] << 8) + data[11]\n\n        selectBank(2);\n\n        // Read accelerometer full scale range and\n        // use it to compensate the reading to gs\n        let scale = (read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n        // scale ranges from section 3.2 of the datasheet\n        let gs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\n        ax /= gs;\n        ay /= gs;\n        az /= gs;\n\n        // Read back the degrees per second rate and\n        // use it to compensate the reading to dps\n        scale = (read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n        // scale ranges from section 3.1 of the datasheet\n        let dps = [131, 65.5, 32.8, 16.4][scale];\n\n        gx /= dps;\n        gy /= dps;\n        gz /= dps;\n\n        return ax, ay, az, gx, gy, gz;\n    }\n\n    set_accelerometer_sample_rate(rate = 125) {\n        /* Set the accelerometer sample rate in Hz. */\n        selectBank(2);\n        // 125Hz - 1.125 kHz / (1 + rate)\n        //rate = Number((1125.0 / rate) - 1);\n        rate = (1125.0 / rate) - 1;\n        // TODO maybe use struct to pack and then this.write_bytes\n        this.write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n        this.write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n    }\n\n    set_accelerometer_full_scale(scale = 16) {\n        /* Set the accelerometer fulls cale range to +- the supplied value. */\n        selectBank(2);\n        let value = this.read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n        ///////value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n        this.write(ICM20948_ACCEL_CONFIG, value);\n    }\n\n    set_accelerometer_low_pass(enabled = true, mode = 5) {\n        /* Configure the accelerometer low pass filter. */\n        selectBank(2);\n        let value = this.read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            this.write(ICM20948_ACCEL_CONFIG, value);\n        }\n    }\n\n    set_gyro_sample_rate(rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        selectBank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = (1125.0 / rate) - 1;\n        this.write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n\n    set_gyro_full_scale(scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        selectBank(2);\n        let value = this.read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        /////value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        this.write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    set_gyro_low_pass(enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        selectBank(2);\n        let value = this.read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n        }\n        value |= (mode & 0x07) << 4;\n        this.write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    read_temperature() {\n        /* Property to read the current IMU temperature */\n        // PWR_MGMT_1 defaults to leave temperature enabled\n        selectBank(0);\n        let temp_raw_bytes = this.read_bytes(ICM20948_TEMP_OUT_H, 2);\n        //let temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0];\n        let temp_raw = (temp_raw_bytes[0] << 8) + temp_raw_bytes[1]\n        let temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n        return temperature_deg_c;\n    }\n}\n}","pxt.json":"{\n    \"name\": \"test_i2c\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\",\n        \"pins_extra.ts\",\n        \"LCM20948.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1760709477982,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n\nconst I2C_ADDR = 0x68;\nconst I2C_ADDR_ALT = 0x69;\n/*\nconst I2C_ADDR_ALT = 0x69;\nconst ICM20948_BANK_SEL = 0x7f;\n\nconst ICM20948_I2C_MST_ODR_CONFIG = 0x00;\nconst ICM20948_I2C_MST_CTRL = 0x01;\nconst ICM20948_I2C_MST_DELAY_CTRL = 0x02;\nconst ICM20948_I2C_SLV0_ADDR = 0x03;\nconst ICM20948_I2C_SLV0_REG = 0x04;\nconst ICM20948_I2C_SLV0_CTRL = 0x05;\nconst ICM20948_I2C_SLV0_DO = 0x06;\nconst ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\nconst ICM20948_GYRO_SMPLRT_DIV = 0x00;\nconst ICM20948_GYRO_CONFIG_1 = 0x01;\nconst ICM20948_GYRO_CONFIG_2 = 0x02;\n\n// Bank 0\nconst ICM20948_WHO_AM_I = 0x00;\nconst ICM20948_USER_CTRL = 0x03;\nconst ICM20948_PWR_MGMT_1 = 0x06;\nconst ICM20948_PWR_MGMT_2 = 0x07;\nconst ICM20948_INT_PIN_CFG = 0x0F;\n\nconst ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\nconst ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\nconst ICM20948_ACCEL_INTEL_CTRL = 0x12;\nconst ICM20948_ACCEL_WOM_THR = 0x13;\nconst ICM20948_ACCEL_CONFIG = 0x14;\nconst ICM20948_ACCEL_XOUT_H = 0x2D;\nconst ICM20948_GRYO_XOUT_H = 0x33;\n\nconst ICM20948_TEMP_OUT_H = 0x39;\nconst ICM20948_TEMP_OUT_L = 0x3A;\n\n// Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nconst ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\nconst ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\nconst ICM20948_ROOM_TEMP_OFFSET = 21;\n\nconst AK09916_I2C_ADDR = 0x0c;\nconst AK09916_CHIP_ID = 0x09;\nconst AK09916_WIA = 0x01;\nconst AK09916_ST1 = 0x10;\nconst AK09916_ST1_DOR = 0b00000010   // Data overflow bit\nconst AK09916_ST1_DRDY = 0b00000001  // Data ready bit\nconst AK09916_HXL = 0x11;\nconst AK09916_ST2 = 0x18;\nconst AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\nconst AK09916_CNTL2 = 0x31;\nconst AK09916_CNTL2_MODE = 0b00001111;\nconst AK09916_CNTL2_MODE_OFF = 0;\nconst AK09916_CNTL2_MODE_SINGLE = 1;\nconst AK09916_CNTL2_MODE_CONT1 = 2;\nconst AK09916_CNTL2_MODE_CONT2 = 4;\nconst AK09916_CNTL2_MODE_CONT3 = 6;\nconst AK09916_CNTL2_MODE_CONT4 = 8;\nconst AK09916_CNTL2_MODE_TEST = 16;\nconst AK09916_CNTL3 = 0x32;\n\n\nlet twoBytes = pins.createBuffer(2)\npins.i2cWriteBuffer(I2C_ADDR,twoBytes,false)\n\n// try addressing the IMU\ndatalogger.mirrorToSerial(true)\ndatalogger.log(datalogger.createCV(\"startup\", 12345))\npins.i2cWriteNumber(I2C_ADDR, ICM20948_WHO_AM_I,NumberFormat.UInt8LE)\nlet me = pins.i2cReadNumber(I2C_ADDR,NumberFormat.UInt8LE,false)\ndatalogger.log(datalogger.createCV(\"me\", me))\n\npins.i2cWriteBuffer(I2C_ADDR,buffer,false)\n*/\nlet imu = new ICM20948(I2C_ADDR)\n\nlet mag:number[] = []\nlet gyro: number[] = []\nwhile (true) {\n    mag = imu.read_magnetometer_data();\n    gyro = imu.read_accelerometer_gyro_data();\n\n    datalogger.log(\n        datalogger.createCV(\"Mag_X\", mag[0]),\n        datalogger.createCV(\"Mag_Y\", mag[1]),\n        datalogger.createCV(\"Mag_Z\", mag[2]),\n        datalogger.createCV(\"Accel_X\", gyro[0]),\n        datalogger.createCV(\"Accel_Y\", gyro[1]),\n        datalogger.createCV(\"Accel_Z\", gyro[2]),\n        datalogger.createCV(\"Spin_X\", gyro[3]),\n        datalogger.createCV(\"Spin_X\", gyro[4]),\n        datalogger.createCV(\"Spin_X\", gyro[5])\n    )\n}\n    /*\n//Accel: {ax:05.2f} {ay:05.2f} {az:05.2f}\n//Gyro:  {gx:05.2f} {gy:05.2f} {gz:05.2f}\n//Mag:   {x:05.2f} {y:05.2f} {z:05.2f}\n\nbasic.pause(250) //time.sleep(0.25)\n*/\n","README.md":"","main.py":"","pins_extra.ts":"/*\nfunction fetch_byte_reg(address: number, byte_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, byte_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Ubyte(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int8LE, false))\n}\ncontrol.waitMicros(4)\n*/\n\n/*\nfunction fetch_word_reg(word_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, word_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Uword(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int16BE, false))\n}\n*/\n/*\nfunction getreg(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt8BE);\n}\n*/\n\n/*\nfunction getInt8LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int8LE);\n}\n*/\n\n/*\nfunction getUInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt16LE);\n}\n*/\n\n/*\nfunction getInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int16LE);\n}\n*/","ICM20948.ts":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\n//namespace ICM {\nconst CHIP_ID = 0xEA;\nconst ICM20948_BANK_SEL = 0x7f;\n\nconst ICM20948_NOT_FOUND = 222; // Panic code!\n\n\nconst ICM20948_I2C_MST_ODR_CONFIG = 0x00;\nconst ICM20948_I2C_MST_CTRL = 0x01;\nconst ICM20948_I2C_MST_DELAY_CTRL = 0x02;\nconst ICM20948_I2C_SLV0_ADDR = 0x03;\nconst ICM20948_I2C_SLV0_REG = 0x04;\nconst ICM20948_I2C_SLV0_CTRL = 0x05;\nconst ICM20948_I2C_SLV0_DO = 0x06;\nconst ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\nconst ICM20948_GYRO_SMPLRT_DIV = 0x00;\nconst ICM20948_GYRO_CONFIG_1 = 0x01;\nconst ICM20948_GYRO_CONFIG_2 = 0x02;\n\n// Bank 0\nconst ICM20948_WHO_AM_I = 0x00;\nconst ICM20948_USER_CTRL = 0x03;\nconst ICM20948_PWR_MGMT_1 = 0x06;\nconst ICM20948_PWR_MGMT_2 = 0x07;\nconst ICM20948_INT_PIN_CFG = 0x0F;\n\nconst ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\nconst ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\nconst ICM20948_ACCEL_INTEL_CTRL = 0x12;\nconst ICM20948_ACCEL_WOM_THR = 0x13;\nconst ICM20948_ACCEL_CONFIG = 0x14;\nconst ICM20948_ACCEL_XOUT_H = 0x2D;\nconst ICM20948_GRYO_XOUT_H = 0x33;\n\nconst ICM20948_TEMP_OUT_H = 0x39;\nconst ICM20948_TEMP_OUT_L = 0x3A;\n\n// Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nconst ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\nconst ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\nconst ICM20948_ROOM_TEMP_OFFSET = 21;\n\nconst AK09916_I2C_ADDR = 0x0c;\nconst AK09916_CHIP_ID = 0x09;\nconst AK09916_WIA = 0x01;\nconst AK09916_NOT_FOUND = 222; // Panic code!\n\nconst AK09916_ST1 = 0x10;\nconst AK09916_ST1_DOR = 0b00000010   // Data overflow bit\nconst AK09916_ST1_DRDY = 0b00000001  // Data ready bit\nconst AK09916_HXL = 0x11;\nconst AK09916_ST2 = 0x18;\nconst AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\nconst AK09916_CNTL2 = 0x31;\nconst AK09916_CNTL2_MODE = 0b00001111;\nconst AK09916_CNTL2_MODE_OFF = 0;\nconst AK09916_CNTL2_MODE_SINGLE = 1;\nconst AK09916_CNTL2_MODE_CONT1 = 2;\nconst AK09916_CNTL2_MODE_CONT2 = 4;\nconst AK09916_CNTL2_MODE_CONT3 = 6;\nconst AK09916_CNTL2_MODE_CONT4 = 8;\nconst AK09916_CNTL2_MODE_TEST = 16;\nconst AK09916_CNTL3 = 0x32;\n// GLOBALS\n\nclass ICM20948 {\n    registerBank: number\n    imuAddress: number\n\n    constructor(myAddress: number) {\n        this.registerBank = -1; // currently-selected register-bank\n        this.imuAddress = myAddress; // I2C master address of ICM20948\n\n        this.selectBank(0);\n        if (this.read(ICM20948_WHO_AM_I) != CHIP_ID) {\n            //throw RuntimeError('Unable to find ICM20948');\n            control.panic(ICM20948_NOT_FOUND)\n        }\n        this.write(ICM20948_PWR_MGMT_1, 0x80);\n        basic.pause(10) //time.sleep(0.01);\n        this.write(ICM20948_PWR_MGMT_1, 0x01);\n        this.write(ICM20948_PWR_MGMT_2, 0x00);\n\n        this.selectBank(2);\n\n        this.set_gyro_sample_rate(100);\n        this.set_gyro_low_pass(true, 5);\n        this.set_gyro_full_scale(250);\n\n        this.set_accelerometer_sample_rate(125);\n        this.set_accelerometer_low_pass(true, 5);\n        this.set_accelerometer_full_scale(16);\n\n        this.selectBank(0);\n        this.write(ICM20948_INT_PIN_CFG, 0x30);\n\n        this.selectBank(3);\n        this.write(ICM20948_I2C_MST_CTRL, 0x4D);\n        this.write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n        if (this.mag_read(AK09916_WIA) != AK09916_CHIP_ID) {\n            // throw RuntimeError('Unable to find AK09916');\n            control.panic(AK09916_NOT_FOUND)\n        }\n        // Reset the magnetometer\n        this.mag_write(AK09916_CNTL3, 0x01);\n        while (this.mag_read(AK09916_CNTL3) == 0x01) {\n            control.waitMicros(100) //time.sleep(0.0001);\n        }\n    }\n\n    write(reg: uint8, value: uint8) {\n        /* Write byte to the sensor. */\n        //_bus.this.write_byte_data(_addr, reg, value);\n\n        let twoBytes = pins.createBuffer(2)\n        twoBytes[0] = I2C_ADDR\n        twoBytes[1] = reg\n        pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n\n    read(reg: uint8) {\n        /* Read byte from the sensor. */\n        // return _bus.read_byte_data(_addr, reg);\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        return pins.i2cReadNumber(I2C_ADDR, NumberFormat.UInt8LE, false)\n    }\n\n    read_bytes(reg: uint8, length = 1) {\n        /* Read byte(s) from the sensor. */\n        // return _bus.read_i2c_block_data(_addr, reg, length);\n        let buf = pins.createBuffer(length)\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        buf = pins.i2cReadBuffer(I2C_ADDR, length, false)\n        return buf\n    }\n\n\n    selectBank(value: uint8) {\n        /* Switch register bank. */\n        if (!(this.registerBank == value)) {\n            this.write(ICM20948_BANK_SEL, value << 4);\n            this.registerBank = value;\n        }\n    }\n    trigger_mag_io() {\n        let user = this.read(ICM20948_USER_CTRL);\n        this.write(ICM20948_USER_CTRL, user | 0x20);\n        control.waitMicros(5000) //time.sleep(0.005);\n        this.write(ICM20948_USER_CTRL, user);\n    }\n\n\n    mag_write(reg: uint8, value: uint8) {\n        /* Write a byte to the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, value);\n        this.selectBank(0);\n        this.trigger_mag_io();\n    }\n\n    mag_read(reg: uint8) {\n        /* Read a byte from the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, 0xff);\n\n        this.selectBank(0);\n        this.trigger_mag_io();\n\n        return this.read(ICM20948_EXT_SLV_SENS_DATA_00);\n    }\n\n\n    mag_read_bytes(reg: uint8, length = 1) {\n        /* Read up to 24 bytes from the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, 0xff);\n        this.selectBank(0);\n        this.trigger_mag_io();\n\n        return this.read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n    }\n\n\n    magnetometer_ready() {\n        /* Check the magnetometer status ready bit. */\n        return (this.mag_read(AK09916_ST1) & 0x01) > 0;\n    }\n\n    read_magnetometer_data(timeout = 1.0) {\n        this.mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n        let t_start = control.millis()\n        while (!this.magnetometer_ready()) {\n            if (control.millis() - t_start > timeout) {\n                /////throw RuntimeError('Timeout waiting for Magnetometer Ready');\n                control.waitMicros(10) //time.sleep(0.00001);\n            }\n            let data = this.mag_read_bytes(AK09916_HXL, 6);\n        }\n        // Read ST2 to confirm read finished,\n        // needed for continuous modes\n        // mag_this.read(AK09916_ST2)\n\n        //////x, y, z = struct.unpack('<hhh', bytearray(data));\n        let x = 0\n        let y = 0\n        let z = 0\n\n        // Scale for magnetic flux density \"uT\"\n        // from section 3.3 of the datasheet\n        // This value is constant\n        x *= 0.15;\n        y *= 0.15;\n        z *= 0.15;\n\n        return x, y, z;\n    }\n    read_accelerometer_gyro_data() {\n        this.selectBank(0);\n        let data = this.read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n        //ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n        //dissect 12 bytes into 6 words\n        let ax = (data[0] << 8) + data[1]\n        let ay = (data[2] << 8) + data[3]\n        let az = (data[4] << 8) + data[5]\n        let gx = (data[6] << 8) + data[7]\n        let gy = (data[8] << 8) + data[9]\n        let gz = (data[10] << 8) + data[11]\n\n        this.selectBank(2);\n\n        // Read accelerometer full scale range and\n        // use it to compensate the reading to gs\n        let scale = (this.read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n        // scale ranges from section 3.2 of the datasheet\n        let gs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\n        ax /= gs;\n        ay /= gs;\n        az /= gs;\n\n        // Read back the degrees per second rate and\n        // use it to compensate the reading to dps\n        scale = (this.read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n        // scale ranges from section 3.1 of the datasheet\n        let dps = [131, 65.5, 32.8, 16.4][scale];\n\n        gx /= dps;\n        gy /= dps;\n        gz /= dps;\n\n        return ax, ay, az, gx, gy, gz;\n    }\n\n    set_accelerometer_sample_rate(rate = 125) {\n        /* Set the accelerometer sample rate in Hz. */\n        this.selectBank(2);\n        // 125Hz - 1.125 kHz / (1 + rate)\n        //rate = Number((1125.0 / rate) - 1);\n        rate = (1125.0 / rate) - 1;\n        // TODO maybe use struct to pack and then this.write_bytes\n        this.write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n        this.write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n    }\n\n    set_accelerometer_full_scale(scale = 16) {\n        /* Set the accelerometer fulls cale range to +- the supplied value. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n        ///////value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n        this.write(ICM20948_ACCEL_CONFIG, value);\n    }\n\n    set_accelerometer_low_pass(enabled = true, mode = 5) {\n        /* Configure the accelerometer low pass filter. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            this.write(ICM20948_ACCEL_CONFIG, value);\n        }\n    }\n\n    set_gyro_sample_rate(rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        this.selectBank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = (1125.0 / rate) - 1;\n        this.write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n\n    set_gyro_full_scale(scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        /////value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        this.write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    set_gyro_low_pass(enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n        }\n        value |= (mode & 0x07) << 4;\n        this.write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    read_temperature() {\n        /* Property to read the current IMU temperature */\n        // PWR_MGMT_1 defaults to leave temperature enabled\n        this.selectBank(0);\n        let temp_raw_bytes = this.read_bytes(ICM20948_TEMP_OUT_H, 2);\n        //let temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0];\n        let temp_raw = (temp_raw_bytes[0] << 8) + temp_raw_bytes[1]\n        let temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n        return temperature_deg_c;\n    }\n}\n","pxt.json":"{\n    \"name\": \"test_ims\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\",\n        \"pins_extra.ts\",\n        \"ICM20948.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1760711304434,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"\n","README.md":"","main.py":"","pins_extra.ts":"/*\nfunction fetch_byte_reg(address: number, byte_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, byte_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Ubyte(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int8LE, false))\n}\ncontrol.waitMicros(4)\n*/\n\n/*\nfunction fetch_word_reg(word_reg: number, select: number): number {\n\n    pins.i2cWriteNumber(MPX_ADDR, select, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    pins.i2cWriteNumber(AS5600_ADDR, word_reg, NumberFormat.Int8LE, false)\n    //  basic.pause(1)\n    return Uword(pins.i2cReadNumber(AS5600_ADDR, NumberFormat.Int16BE, false))\n}\n*/\n/*\nfunction getreg(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt8BE);\n}\n*/\n\n/*\nfunction getInt8LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int8LE);\n}\n*/\n\n/*\nfunction getUInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt16LE);\n}\n*/\n\n/*\nfunction getInt16LE(reg: number): number {\n    pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n    return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int16LE);\n}\n*/","ICM20948.ts":"\n// TypeScript driver for Microbit (inspired by https://github.com/pimoroni/icm20948-python)\n\n//namespace ICM {\nconst CHIP_ID = 0xEA;\nconst ICM20948_BANK_SEL = 0x7f;\n\nconst ICM20948_NOT_FOUND = 222; // Panic code!\n\n\nconst ICM20948_I2C_MST_ODR_CONFIG = 0x00;\nconst ICM20948_I2C_MST_CTRL = 0x01;\nconst ICM20948_I2C_MST_DELAY_CTRL = 0x02;\nconst ICM20948_I2C_SLV0_ADDR = 0x03;\nconst ICM20948_I2C_SLV0_REG = 0x04;\nconst ICM20948_I2C_SLV0_CTRL = 0x05;\nconst ICM20948_I2C_SLV0_DO = 0x06;\nconst ICM20948_EXT_SLV_SENS_DATA_00 = 0x3B;\n\nconst ICM20948_GYRO_SMPLRT_DIV = 0x00;\nconst ICM20948_GYRO_CONFIG_1 = 0x01;\nconst ICM20948_GYRO_CONFIG_2 = 0x02;\n\n// Bank 0\nconst ICM20948_WHO_AM_I = 0x00;\nconst ICM20948_USER_CTRL = 0x03;\nconst ICM20948_PWR_MGMT_1 = 0x06;\nconst ICM20948_PWR_MGMT_2 = 0x07;\nconst ICM20948_INT_PIN_CFG = 0x0F;\n\nconst ICM20948_ACCEL_SMPLRT_DIV_1 = 0x10;\nconst ICM20948_ACCEL_SMPLRT_DIV_2 = 0x11;\nconst ICM20948_ACCEL_INTEL_CTRL = 0x12;\nconst ICM20948_ACCEL_WOM_THR = 0x13;\nconst ICM20948_ACCEL_CONFIG = 0x14;\nconst ICM20948_ACCEL_XOUT_H = 0x2D;\nconst ICM20948_GRYO_XOUT_H = 0x33;\n\nconst ICM20948_TEMP_OUT_H = 0x39;\nconst ICM20948_TEMP_OUT_L = 0x3A;\n\n// Offset and sensitivity - defined in electrical characteristics, and TEMP_OUT_H/L of datasheet\nconst ICM20948_TEMPERATURE_DEGREES_OFFSET = 21;\nconst ICM20948_TEMPERATURE_SENSITIVITY = 333.87;\nconst ICM20948_ROOM_TEMP_OFFSET = 21;\n\nconst AK09916_I2C_ADDR = 0x0c;\nconst AK09916_CHIP_ID = 0x09;\nconst AK09916_WIA = 0x01;\nconst AK09916_NOT_FOUND = 333; // Panic code!\n\nconst AK09916_ST1 = 0x10;\nconst AK09916_ST1_DOR = 0b00000010   // Data overflow bit\nconst AK09916_ST1_DRDY = 0b00000001  // Data ready bit\nconst AK09916_HXL = 0x11;\nconst AK09916_ST2 = 0x18;\nconst AK09916_ST2_HOFL = 0b00001000  // Magnetic sensor overflow bit\nconst AK09916_CNTL2 = 0x31;\nconst AK09916_CNTL2_MODE = 0b00001111;\nconst AK09916_CNTL2_MODE_OFF = 0;\nconst AK09916_CNTL2_MODE_SINGLE = 1;\nconst AK09916_CNTL2_MODE_CONT1 = 2;\nconst AK09916_CNTL2_MODE_CONT2 = 4;\nconst AK09916_CNTL2_MODE_CONT3 = 6;\nconst AK09916_CNTL2_MODE_CONT4 = 8;\nconst AK09916_CNTL2_MODE_TEST = 16;\nconst AK09916_CNTL3 = 0x32;\n// GLOBALS\n\nclass ICM20948 {\n    registerBank: number\n    imuAddress: number\n\n    constructor(myAddress: number) {\n        this.registerBank = -1; // currently-selected register-bank\n        this.imuAddress = myAddress; // I2C master address of ICM20948\n\n        this.selectBank(0);\n        if (this.read(ICM20948_WHO_AM_I) != CHIP_ID) {\n            //throw RuntimeError('Unable to find ICM20948');\n            control.panic(ICM20948_NOT_FOUND)\n        }\n        this.write(ICM20948_PWR_MGMT_1, 0x80);\n        basic.pause(10) //time.sleep(0.01);\n        this.write(ICM20948_PWR_MGMT_1, 0x01);\n        this.write(ICM20948_PWR_MGMT_2, 0x00);\n\n        this.selectBank(2);\n\n        this.set_gyro_sample_rate(100);\n        this.set_gyro_low_pass(true, 5);\n        this.set_gyro_full_scale(250);\n\n        this.set_accelerometer_sample_rate(125);\n        this.set_accelerometer_low_pass(true, 5);\n        this.set_accelerometer_full_scale(16);\n\n        this.selectBank(0);\n        this.write(ICM20948_INT_PIN_CFG, 0x30);\n\n        this.selectBank(3);\n        this.write(ICM20948_I2C_MST_CTRL, 0x4D);\n        this.write(ICM20948_I2C_MST_DELAY_CTRL, 0x01);\n\n        if (this.mag_read(AK09916_WIA) != AK09916_CHIP_ID) {\n            // throw RuntimeError('Unable to find AK09916');\n            control.panic(AK09916_NOT_FOUND)\n        }\n        // Reset the magnetometer\n        this.mag_write(AK09916_CNTL3, 0x01);\n        while (this.mag_read(AK09916_CNTL3) == 0x01) {\n            control.waitMicros(100) //time.sleep(0.0001);\n        }\n    }\n\n    write(reg:number, value:number) {\n        /* Write byte to the sensor. */\n        //_bus.this.write_byte_data(_addr, reg, value);\n\n        let twoBytes = pins.createBuffer(2)\n        twoBytes[0] = I2C_ADDR\n        twoBytes[1] = reg\n        pins.i2cWriteBuffer(I2C_ADDR, twoBytes, false)\n        control.waitMicros(100) //time.sleep(0.0001);\n    }\n\n    read(reg: number) {\n        /* Read byte from the sensor. */\n        // return _bus.read_byte_data(_addr, reg);\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        return pins.i2cReadNumber(I2C_ADDR, NumberFormat.UInt8LE, false)\n    }\n\n    read_bytes(reg: number, length = 1) {\n        /* Read byte(s) from the sensor. */\n        // return _bus.read_i2c_block_data(_addr, reg, length);\n        let buf = pins.createBuffer(length)\n        pins.i2cWriteNumber(I2C_ADDR, reg, NumberFormat.UInt8LE)\n        buf = pins.i2cReadBuffer(I2C_ADDR, length, false)\n        return buf\n    }\n\n\n    selectBank(value: number) {\n        /* Switch register bank. */\n        if (!(this.registerBank == value)) {\n            this.write(ICM20948_BANK_SEL, value << 4);\n            this.registerBank = value;\n        }\n    }\n    trigger_mag_io() {\n        let user = this.read(ICM20948_USER_CTRL);\n        this.write(ICM20948_USER_CTRL, user | 0x20);\n        control.waitMicros(5000) //time.sleep(0.005);\n        this.write(ICM20948_USER_CTRL, user);\n    }\n\n\n    mag_write(reg: number, value: number) {\n        /* Write a byte to the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR)  // Write one byte\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, value);\n        this.selectBank(0);\n        this.trigger_mag_io();\n    }\n\n    mag_read(reg: number) {\n        /* Read a byte from the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, 0xff);\n\n        this.selectBank(0);\n        this.trigger_mag_io();\n\n        return this.read(ICM20948_EXT_SLV_SENS_DATA_00);\n    }\n\n\n    mag_read_bytes(reg: number, length = 1) {\n        /* Read up to 24 bytes from the slave magnetometer. */\n        this.selectBank(3);\n        this.write(ICM20948_I2C_SLV0_CTRL, 0x80 | 0x08 | length);\n        this.write(ICM20948_I2C_SLV0_ADDR, AK09916_I2C_ADDR | 0x80);\n        this.write(ICM20948_I2C_SLV0_REG, reg);\n        this.write(ICM20948_I2C_SLV0_DO, 0xff);\n        this.selectBank(0);\n        this.trigger_mag_io();\n\n        return this.read_bytes(ICM20948_EXT_SLV_SENS_DATA_00, length);\n    }\n\n\n    magnetometer_ready() {\n        /* Check the magnetometer status ready bit. */\n        return (this.mag_read(AK09916_ST1) & 0x01) > 0;\n    }\n\n    read_magnetometer_data(timeout = 1.0) {\n        this.mag_write(AK09916_CNTL2, 0x01)  // Trigger single measurement\n        let t_start = control.millis()\n        let data:Buffer\n        while (!this.magnetometer_ready()) {\n            if (control.millis() - t_start > timeout) {\n                /////throw RuntimeError('Timeout waiting for Magnetometer Ready');\n                control.waitMicros(10) //time.sleep(0.00001);\n            }\n            data = this.mag_read_bytes(AK09916_HXL, 6);\n        }\n        // Read ST2 to confirm read finished,\n        // needed for continuous modes\n        // mag_this.read(AK09916_ST2)\n\n        //////x, y, z = struct.unpack('<hhh', bytearray(data));\n        let x = data.getNumber(NumberFormat.UInt16LE, 0)\n        let y = data.getNumber(NumberFormat.UInt16LE, 2)\n        let z = data.getNumber(NumberFormat.UInt16LE, 4)\n\n        // Scale for magnetic flux density \"uT\"\n        // from section 3.3 of the datasheet\n        // This value is constant\n        x *= 0.15;\n        y *= 0.15;\n        z *= 0.15;\n\n        return [x, y, z];\n    }\n    read_accelerometer_gyro_data() {\n        this.selectBank(0);\n        let data = this.read_bytes(ICM20948_ACCEL_XOUT_H, 12);\n        //ax, ay, az, gx, gy, gz = struct.unpack('>hhhhhh', bytearray(data));\n        //dissect 12 bytes into 6 words\n        let ax = data.getNumber(NumberFormat.UInt16LE, 0)\n        let ay = data.getNumber(NumberFormat.UInt16LE, 2)\n        let az = data.getNumber(NumberFormat.UInt16LE, 4)\n        let gx = data.getNumber(NumberFormat.UInt16LE, 6)\n        let gy = data.getNumber(NumberFormat.UInt16LE, 8)\n        let gz = data.getNumber(NumberFormat.UInt16LE, 10)\n\n        this.selectBank(2);\n\n        // Read accelerometer full scale range and\n        // use it to compensate the reading to gs\n        let scale = (this.read(ICM20948_ACCEL_CONFIG) & 0x06) >> 1;\n\n        // scale ranges from section 3.2 of the datasheet\n        let gs = [16384.0, 8192.0, 4096.0, 2048.0][scale];\n\n        ax /= gs;\n        ay /= gs;\n        az /= gs;\n\n        // Read back the degrees per second rate and\n        // use it to compensate the reading to dps\n        scale = (this.read(ICM20948_GYRO_CONFIG_1) & 0x06) >> 1;\n\n        // scale ranges from section 3.1 of the datasheet\n        let dps = [131, 65.5, 32.8, 16.4][scale];\n\n        gx /= dps;\n        gy /= dps;\n        gz /= dps;\n\n        return [ax, ay, az, gx, gy, gz];\n    }\n\n    set_accelerometer_sample_rate(rate = 125) {\n        /* Set the accelerometer sample rate in Hz. */\n        this.selectBank(2);\n        // 125Hz - 1.125 kHz / (1 + rate)\n        //rate = Number((1125.0 / rate) - 1);\n        rate = (1125.0 / rate) - 1;\n        // TODO maybe use struct to pack and then this.write_bytes\n        this.write(ICM20948_ACCEL_SMPLRT_DIV_1, (rate >> 8) & 0xff);\n        this.write(ICM20948_ACCEL_SMPLRT_DIV_2, rate & 0xff);\n    }\n\n    set_accelerometer_full_scale(scale = 16) {\n        /* Set the accelerometer fulls cale range to +- the supplied value. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_ACCEL_CONFIG) & 0b11111001;\n        ///////value |= { 2: 0b00, 4: 0b01, 8: 0b10, 16: 0b11 }[scale] << 1;\n        this.write(ICM20948_ACCEL_CONFIG, value);\n    }\n\n    set_accelerometer_low_pass(enabled = true, mode = 5) {\n        /* Configure the accelerometer low pass filter. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_ACCEL_CONFIG) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n            value |= (mode & 0x07) << 4;\n            this.write(ICM20948_ACCEL_CONFIG, value);\n        }\n    }\n\n    set_gyro_sample_rate(rate = 125) {\n        /* Set the gyro sample rate in Hz. */\n        this.selectBank(2);\n        // 125Hz sample rate - 1.125 kHz / (1 + rate)\n        rate = (1125.0 / rate) - 1;\n        this.write(ICM20948_GYRO_SMPLRT_DIV, rate);\n    }\n\n    set_gyro_full_scale(scale = 250) {\n        /* Set the gyro full scale range to +- supplied value. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_GYRO_CONFIG_1) & 0b11111001;\n        /////value |= { 250: 0b00, 500: 0b01, 1000: 0b10, 2000: 0b11 }[scale] << 1;\n        this.write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    set_gyro_low_pass(enabled = true, mode = 5) {\n        /* Configure the gyro low pass filter. */\n        this.selectBank(2);\n        let value = this.read(ICM20948_GYRO_CONFIG_1) & 0b10001110;\n        if (enabled) {\n            value |= 0b1;\n        }\n        value |= (mode & 0x07) << 4;\n        this.write(ICM20948_GYRO_CONFIG_1, value);\n    }\n\n    read_temperature() {\n        /* Property to read the current IMU temperature */\n        // PWR_MGMT_1 defaults to leave temperature enabled\n        this.selectBank(0);\n        let temp_raw_bytes = this.read_bytes(ICM20948_TEMP_OUT_H, 2);\n        //let temp_raw = struct.unpack('>h', bytearray(temp_raw_bytes))[0];\n        let temp_raw = (temp_raw_bytes[0] << 8) + temp_raw_bytes[1]\n        let temperature_deg_c = ((temp_raw - ICM20948_ROOM_TEMP_OFFSET) / ICM20948_TEMPERATURE_SENSITIVITY) + ICM20948_TEMPERATURE_DEGREES_OFFSET;\n        return temperature_deg_c;\n    }\n}\n","pxt.json":"{\n    \"name\": \"test_ims\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\",\n        \"pins_extra.ts\",\n        \"ICM20948.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1760712762285}